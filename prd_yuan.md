# 类《Across the Obelisk》卡牌构筑RPG游戏 PRD（基于 Godot+C#）

**引言与目标**

本项目旨在使用 Godot 游戏引擎（C#）开发一款类《Across the Obelisk》的卡牌构筑RPG游戏。游戏融合*卡牌构筑*与*角色扮演*元素，支持玩家率领一支英雄小队进行冒险。核心玩法包括构建牌组、策略回合战斗、角色养成，以及在分支地图上进行事件抉择。

---

## 主要目标

- **丰富的卡牌系统**： 提供多样化的卡牌供玩家收集和构筑牌组，每张卡牌有独特效果，满足策略搭配需求
- **策略战斗体验**： 采用回合制卡牌战斗，小队英雄各具职业和牌组，合理出牌击败敌人。战斗需要权衡攻击、防御与技能组合
- **深入的角色养成**： 英雄角色可以升级成长，提升属性解锁天赋（未来可扩展装备、技能树等），增强长期养成乐趣
- **丰富的事件与探索**： 在冒险地图上遇到随机事件和分支选择，玩家决策将影响后续旅程走向和资源获取，提高每次游戏的新鲜感
- **高度扩展性**： 系统架构遵循 Arc42/C4 标准，模块化设计，方便未来添加*剧情章节*、*装备系统*等重大功能而无需推翻重构

---

## 技术约束

- 平台限定为 *Windows PC*（利用 Godot 4 C# 模板提供的 Windows-only 优化）。
- 引擎采用 *Godot 4.5 + .NET 8*，利用其高性能2D渲染和C#脚本能力。
- 架构上使用**端口-适配器（Hexagonal）**思想，将核心逻辑与引擎分离，确保模块解耦和易测试，满足企业级质量要求。
- 数据持久化采用本地*SQLite数据库*或文件，用于保存玩家进度、卡牌库等（通过插件 godot-sqlite 实现）。

---

**系统上下文**

本游戏为*单机本地游戏*。系统环境的上下文如下：玩家通过键鼠等输入设备与游戏客户端交互，所有游戏逻辑在本地 Godot 客户端上执行。当前版本为离线单机运行（仅可能集成崩溃日志上报等第三方跨切面功能）。
在 C4 模型的系统环境图中，可以简单表示为：
*玩家* →（输入）→ *游戏客户端（Godot+C#）* →（输出）→ *本地存储*（保存进度/日志）。
游戏客户端作为系统核心，与操作系统和硬件交互呈现音视频输出。

---

## 核心游戏循环（Gameplay Loop）

游戏的基本闭环流程如下（单人模式下玩家控制全队英雄）：
1.	**冒险准备**： 玩家开始新冒险，选择初始英雄小队组成（例如4名英雄，各自职业不同）和初始卡组。
2.	**地图探索**： 进入章节地图，在节点图（连线/可达关系）上选择前进路线。地图由若干节点组成，类型包括战斗、事件、商店、休息等。玩家权衡队伍状态和奖励，在相邻节点中选择下一步路径。
3.	**遭遇战斗**： 若进入*战斗节点*，切换到战斗场景。战斗为回合制：每回合英雄和敌人按顺序行动。玩家从英雄的手牌中打出卡牌对敌方造成效果（如攻击、防御、治疗等），消耗能量或资源。回合之间可能抽牌、弃牌，直至战斗一方全灭。战斗胜利则结束战斗，给予战利品和经验；若失败则本次冒险结束。
4.	**事件抉择**： 若进入*事件节点*，出现叙事事件或情景描述。玩家在多个选项中进行决策，每个选项会带来不同结果（奖励、惩罚、状态变化等）。决策可能影响后续剧情走向或队伍属性。做出选择后，应用事件结果并继续冒险。
5.	**奖励与成长**： 在战斗胜利或特定事件后，玩家可能获得新卡牌、金币或道具等奖励，并有机会*构筑调整*（如从若干卡牌中选择一张加入牌组，或移除/升级牌组中的卡牌）。英雄获得经验值累积升级，提高属性并解锁新天赋或技能卡。
6.	**持续探索**： 地图探索和节点遭遇交替进行。玩家在地图上不断前进，重复战斗和事件过程，期间管理卡组和角色状态，使队伍尽量维持战斗力。每张地图末端通常有强大的首领战斗作为章节挑战。
7.	**章节推进与结局**： 击败章节首领后，进入下一章节地图（难度提升，可能增加新的敌人和事件）。如此循环直至完成所有章节，迎来最终首领战并取得胜利（或全队阵亡结束冒险）。游戏具有Roguelite特性，即便失败也能根据表现解锁部分内容，为下次冒险做准备。

该核心循环确保了*卡牌构筑*（通过不断获得新牌、优化牌组）与*RPG养成*（角色升级成长）交替进行，配合*地图探索*和*事件决策*带来的分支变化，形成富有策略深度和重玩价值的玩法闭环。

---

## 架构概览（Arc42/C4 容器视图）

系统采用*分层解耦*的架构，主要分为以下几个容器/子系统：

- **游戏客户端（Godot 容器）**： 承载游戏运行的引擎环境，包含场景树、渲染和音频系统，以及输入处理等。Godot 引擎负责*表现层*（UI动画、特效）和资源管理。本项目使用 Godot 的 C# 脚本能力，将业务逻辑以 C# 程序集形式嵌入。
- **核心逻辑模块（Game Core，C#）**： 包含游戏的主要业务逻辑和数据模型，以独立的 C# 类实现。核心逻辑通过*端口接口*与引擎交互，以保持与框架的低耦合。关键的游戏规则（如卡牌效果计算、战斗回合流程等）都在核心模块中实现，便于单元测试和逻辑复用。
- **界面与场景模块（Game UI，Godot 场景树）**： 包括各种游戏场景和UI控件，例如主菜单、地图界面、战斗界面、卡牌手牌UI等。这一层通过调用核心逻辑提供的接口或发送事件来驱动游戏进程，并监听核心反馈更新显示。UI层严格分离逻辑，只关注呈现和玩家交互。
- **系统工具模块（单例Autoload）**： 提供全局服务，如事件总线(EventBus)、数据存储(DataStore)、日志(Logger)、音频(Audio)、时间(Time)、**输入管理(Input)**等GitHubGitHub。例如，事件总线用于解耦模块通信，核心逻辑可分发事件（如“卡牌已使用”、“敌人死亡”），UI层订阅这些事件来更新显示GitHub。数据存储提供统一接口读写数据库或文件，用于保存进度或加载资源。
- **数据持久层**： 通过 SQLite 数据库或JSON文件保存*元数据*和*进度*。元数据包括卡牌、敌人、事件等配置（可能直接以资源文件形式加载）；进度数据包括玩家解锁的内容、存档的英雄状态等。封装数据访问模块以支持更丰富的本地存档能力（多存档位、版本迁移、回放/调试快照）。

**模块间交互**：*采用发布-订阅*和*接口调用*相结合的方式。UI场景通过调用核心模块方法触发游戏行为，例如玩家点击“打出卡牌”按钮调用战斗系统的出牌接口；核心逻辑处理完毕后，通过事件总线发布结果事件（如减血变化），UI层对应的节点监听到事件后更新数值或播放动画。这样的架构保证*模块职责*清晰，各司其职，同时通过事件和接口契约保持松耦合，方便替换或扩展模块实现。

**扩展性考虑**：以上容器设计使得新增功能时只需增加相应模块而无需大改其他部分。例如，引入**新系统（如装备）**可通过扩展核心数据模型和在界面层增加装备UI来实现。由于核心逻辑与渲染层解耦，甚至可以替换UI（比如将部分逻辑用于控制台模式跑自动化测试）而不影响游戏规则本身。
下面按功能纵切视角，详细说明各核心模块的职责与设计，以及为未来扩展预留的接口。

---

## 模块设计与功能定义

### 卡牌系统模块

**模块职责**：**管理游戏中的所有卡牌定义和牌组构筑逻辑**，是整个游戏的核心机制之一。卡牌系统负责定义*卡牌数据结构*、管理玩家和敌人的**牌库/牌堆**，以及**执行卡牌效果**。每张卡牌拥有名称、能量消耗、类型（如攻击、防御、技能）、效果描述等属性，可能还有稀有度或升级等级。

**核心功能**：
- **卡牌数据库**： 预先定义大量卡牌并存储其属性及效果脚本。可采用数据驱动方式配置卡牌，例如用 JSON 或资源文件列出卡牌属性，加载为卡牌对象。
- **牌组构筑**： 维护每个英雄的牌库和牌组。游戏开始时根据英雄职业给予基础牌组，战斗/事件奖励可新增卡牌，玩家也可以在特定节点移除/替换卡牌，从而逐步优化牌组。卡牌系统提供接口用于**增删卡、洗牌、抽牌、弃牌**等操作，确保这些操作遵循规则（如每回合抽N张牌，牌库耗尽时将弃牌堆洗切重新成为牌库等）。
- **卡牌出牌流程**： 当玩家选择打出一张卡牌时，卡牌系统检查其使用条件（例如能量是否足够、特定情况下才能使用等），然后通知战斗模块应用该卡牌效果。效果的具体逻辑（如造成伤害、治疗、增益）可以由卡牌自身携带的脚本或由战斗系统解析卡牌的效果字段执行。使用后，卡牌通常移入弃牌堆。卡牌系统也处理一些全局卡牌机制，如状态持续牌（Buff/Debuff卡）放置在场上持续作用若干回合。
- **卡牌效果扩展**： 系统支持多种类型的卡牌效果，包括直接伤害、治疗、护盾、增益/减益状态、抽牌、消耗等。采用**策略模式**或脚本驱动，使得新增卡牌效果无需修改核心代码，只需添加新的效果处理逻辑模块。例如，可以定义接口ICardEffect，不同效果实现该接口；卡牌数据中指明所用效果类，这样在出牌时调用对应实现。

**设计示例**： 每张卡牌在C#中表现为Card类对象，包含Play(target)方法。当卡牌被打出时，Card.Play()内部通过事件总线发出CardPlayed事件，附带卡牌ID和目标等信息。战斗系统订阅此事件并接收卡牌信息，依据卡牌类型调用适当的效果处理函数。处理完成后，卡牌系统将卡牌移至弃牌堆并更新手牌。

**扩展性**：
- **新增卡牌**：由于卡牌数据驱动和效果多态设计，添加新卡牌只需在配置中加入新条目，并（如果是新效果）实现对应效果类，不影响现有逻辑。
- **牌组规则变化**：可通过调整卡牌系统参数支持不同的抽牌数量、手牌上限等规则。未来如增加特殊牌堆（比如遗物牌堆、移除出游戏的放逐堆等），也可在此模块扩展数据结构支持。
- **装备/状态对卡牌的影响**： 模块提供接口让角色装备或状态修改卡牌行为，比如某装备使特定类型卡牌+1伤害。这通过在卡牌计算效果时查询角色状态来实现。设计上卡牌效果计算会引用角色当前属性，确保未来加入装备系统时，只需在角色属性上反映装备加成，卡牌系统无需改动即可兼容。
- **多角色牌组**：支持**每个英雄**拥有各自的牌组，模块内部按英雄区分牌堆。我们在卡牌系统中通过英雄ID或所属引用，将牌组与英雄对象关联，实现手牌与牌堆的独立管理。

### 战斗系统模块

**模块职责**：**战斗系统掌管回合制战斗逻辑**，负责处理战斗流程、伤害计算和胜负判断。该模块与卡牌系统联动：接受卡牌系统传来的出牌动作，执行其效果在战场上。战斗系统还需管理**战场状态**，包括英雄和敌方单位的属性、状态效果，以及回合顺序。

**核心功能**：
- **战场初始化**： 进入战斗节点时，战斗系统根据当前地图进度生成敌人队列（数量和强度按章节/难度而定）。创建战斗实例，包括玩家英雄队伍（从角色模块获取当前英雄列表和属性）和敌人列表（从敌人配置库读取）。设置初始战斗顺序（例如按照角色敏捷属性或预设顺序决定先后）。
- **回合流程管理**： 实现战斗的循环结构：从回合开始 → 判断当前主动方（英雄或敌人）的行动 → 行动完成后处理状态变化 → 检查战斗结束条件 → 切换下一个单位。对于英雄，由玩家通过**卡牌系统**选择行动；对于敌人，则由AI模块或预设模式决定行动（例如使用某张技能卡或普通攻击）。战斗系统在内部维护一个**回合管理器**或状态机，确保严格按照阶段顺序执行（开始阶段、主要行动阶段、结束阶段等），并广播相应事件（如“TurnStart”“TurnEnd”）。
- **伤害与效果处理**： 战斗系统计算卡牌或技能对目标造成的影响，包括扣除生命值、增加护盾、附加状态效果等。例如，当接收到卡牌系统的“攻击卡牌使用”事件时，战斗系统根据卡牌威力和施法者属性计算伤害值，调用角色模块接口减少敌人生命。同时战斗系统会生成动画/特效指令供UI显示（通过事件总线通知UI模块播放攻击动画）。各种效果如治疗、增益(buff)/减益(debuff)也在此处理，需更新相应角色的状态列表。
- **状态与Buff管理**： 为实现复杂战斗机制，战斗系统维护一个**状态效果子模块**，跟踪战斗中临时状态（例如中毒、流血、护盾、力量提升等）。状态具有持续回合数或条件，战斗系统每回合更新状态（减少持续时间、结算持续伤害等）。状态模块也提供接口给卡牌效果调用（例如某卡牌使目标眩晕2回合，则调用状态模块添加“眩晕”状态到目标）。
- **胜负判定与结算**： 每当一方单位生命降至0，战斗系统将其标记为死亡，移出战斗顺序。当所有敌人死亡则判定胜利；若我方队伍全灭则判定失败。战斗结束时战斗系统计算战利品和经验奖励：可以根据敌人强度从**掉落模块**获取物品/金币奖励清单，经验则分配给存活英雄。然后触发“BattleEnd”事件，携带胜负结果及奖励信息。上层流程会根据结果进入后续（胜利则发放奖励并返回地图，失败则结束冒险）。

**设计示例**： 战斗系统主要由BattleManager类驱动，其内含列表heroes和enemies及当前行动索引。每回合开始时，BattleManager按顺序从列表取出当前行动者unit：如果是英雄且由玩家控制，则战斗系统暂停流程，等待卡牌系统输入玩家选择；如果是敌人或AI控制英雄，则调用该单位的Act()方法自动执行行动（比如出一张卡或攻击）。行动执行通过调用战斗系统自己的ApplyCardEffect(card, source, target)等方法实现，将效果转换为数值修改和状态变化。整个过程中，BattleManager会派发各种事件（如TurnChanged、UnitAttacked等）供UI监听。

**扩展性**：
- **多样敌人和AI**： 敌人数据和AI行为通过**策略模式**实现。可以为不同敌人配置不同的AI脚本（如简单攻击最近英雄、或有技能循环）。增加新敌人只需提供新的配置和AI行为，无需改动战斗主逻辑。战斗系统通过接口IEnemyAI与敌人挂钩，使AI决策独立于战斗循环本身。
- **更多战斗机制**： 未来可添加**区域攻击、连携技、环境元素**等高级机制。由于当前架构将伤害计算和状态管理集中处理，扩展机制时可在相关部分增加新类型效果。例如增加“环境陷阱”可在战场对象列表中加入环境对象，并在回合循环中检查环境对象效果。现有设计的事件机制也允许插入新事件类型（比如环境每回合触发伤害事件）。
- **性能与容量**： 战斗系统需考虑性能（特别在大量敌人或状态时）。当前设计每帧仅处理当前单位行动，其他运算仅在回合切换时批量处理状态，从而控制复杂度。未来扩展大量敌人时，可考虑将战斗计算放入独立线程，但接口不变。

### 角色成长系统模块

**模块职责**：**角色成长模块管理玩家英雄角色**的属性、等级和长期养成要素。每位英雄都有独立的角色档案，包括基础属性（生命值、攻击力、防御、敏捷等）、职业定位、当前等级和经验值、已解锁的天赋/技能等。该模块提供英雄状态的读写接口，并在适当时机（如战斗结束、经验累积）处理角色升级和属性变化。

**核心功能**：
- **英雄数据模型**： 定义Hero类表示玩家角色，包含静态部分（职业、初始属性、成长曲线、技能卡池）和动态部分（当前属性值、等级、经验、装备、状态效果）。职业决定了英雄可用的卡牌类型和成长偏向，例如战士职业生命和力量成长高，法师职业法力与魔力成长高等。角色初始属性和每级增长可在配置表中定义，角色模块根据经验计算等级提升。
- **经验与升级**： 角色模块监听战斗结束时分配的经验值，将其累加到对应英雄的experience。当经验达到升级所需阈值时，触发英雄升级流程：英雄等级level加1，提升相应属性值（按职业成长曲线），并**授予成长奖励**。奖励可以包括提升基础属性、从职业卡牌池中**解锁新卡牌**加入牌组、或**天赋点**用于学习特殊技能。角色模块负责处理升级时属性和卡牌的具体增加，并记录英雄新状态。升级信息通过事件通知UI，例如弹出“英雄升级”界面供玩家选择奖励（如果有分支奖励选项）。
- **属性计算与装备加成**： 角色当前属性可能受到多方面影响：基础属性随等级提升，临时属性受战斗中Buff/Debuff影响，装备则提供额外加成。角色模块提供统一接口计算某项属性的当前值（例如GetCurrentAttack()），内部将基础值、装备加成、Buff效果叠加后返回。这种设计让其他模块（战斗、卡牌效果）无需关心装备或状态细节，只调用角色模块获取最终数值。例如战斗系统在计算伤害时调用英雄的GetCurrentAttack()获取攻击强度。若未来增加装备系统，只需在此接口增加装备对属性的贡献。
- **队伍和角色管理**： 角色模块还维护玩家当前小队的英雄列表（如最多4人），并提供增删队员的功能（未来可能有招募新英雄）。小队信息用于战斗和事件场景，例如战斗系统从角色模块获取队伍成员初始属性，事件系统可能需要获取某角色特定属性做判定（如智力检定）。角色模块确保队伍中每个英雄数据的同步更新（例如冒险过程中HP变化保存下来）。

**设计示例**： HeroManager类维护一个List<Hero> party表示玩家当前小队。每个Hero对象包含level, exp, baseStats, currentStats, talentsUnlocked等属性。战斗结束时，HeroManager.AddExperience(hero, expAmount)方法为传入英雄增加经验，检查hero.exp是否超过当前等级的升级需求（可从职业配置中取出经验表）。如果是，则调用hero.LevelUp()执行升级：提高等级，增加baseStats（例如生命+10，攻击+2等），并通过事件总线发出HeroLeveledUp事件附带英雄ID。UI监听该事件，提示玩家为该英雄选择天赋或新卡牌（具体选项由职业配置决定，例如每升2级可以从3张职业卡中选1张加入牌组）。玩家的选择通过UI层调用角色模块的hero.LearnTalent(talentId)或hero.AddCard(cardId)来落实。

**扩展性**：
- **装备系统集成**： 未来计划加入装备/道具，角色模块已预留接口和数据结构。例如Hero对象可包含equipmentSlots字典，放置武器、防具等物品，这些物品对属性的修改在GetCurrentAttack()等计算中体现。同时角色模块可以提供EquipItem(item)方法处理装备更换逻辑。由于目前其它模块通过角色接口获取属性，这种更改是透明的，无需改动战斗或卡牌系统即可支持装备影响。
- **深度剧情关联**： 深度剧情可能要求角色有**声望或特质**，比如某英雄通过特定剧情获得“诅咒”特质影响战斗表现。角色模块可以拓展英雄状态字段，例如增加traits列表，用于存储剧情赋予的永久特质。这些特质的效果可以在相关模块检查（如一个“诅咒”特质让治疗效果减半，战斗系统计算治疗时查找英雄是否有该特质）。增加这些特质数据对角色模块来说是小幅扩展，且架构上已有Buff/状态机制，可部分复用。
- **更多角色和职业**： 扩充英雄池仅需增加新职业配置和初始卡牌列表，并提供对应的美术资源。由于卡牌和战斗机制通用，新职业主要影响成长数值和可用卡牌，不涉及架构改变。角色模块的数据结构（如经验表、属性表）设计成可支持多个职业条目，新增职业时按约定添加配置即可。

### 事件决策系统模块

**模块职责**：**事件系统负责游戏中随机事件**和**剧情节点**的呈现与逻辑处理。它管理一系列预定义的事件，包括事件描述、选项和对应的后果。该模块驱动玩家在冒险过程中遇到**抉择**：玩家的选择将调用事件系统应用相应效果（改变资源、属性或引发后续剧情）。事件系统旨在使每次冒险充满不确定性和故事性。

**核心功能**：
- **事件定义与加载**： 通过数据文件定义大量事件。每个事件包含：文本描述、若干选项，每个选项有描述和后果。后果可以是简单的数值变化（如“获得金币100”）、状态改变（如“全队中毒”）、物品/卡牌奖励，甚至可能**触发战斗**或**解锁隐藏路线**。事件数据支持条件触发（例如某事件只有在特定章节出现，或某英雄在队伍时才出现特殊选项）。事件系统在游戏初始化或进入章节时加载适用的事件列表备用。
- **事件触发与呈现**： 当玩家走到地图上的**事件节点**时，事件系统从当前章节的事件库中选取一个事件（可随机或固定映射）。然后通过UI模块展示事件的文字和选项按钮。玩家做出选择后，UI将所选选项ID反馈给事件系统。事件系统据此执行预定义的后果逻辑。为方便扩展，后果逻辑可采用**脚本化**：例如用一种简单脚本或配置指令表示“Hero[0].HP -= 10; GiveItem(potion)”等，由事件系统解析执行。这样策划添加新事件时，无需写C#代码，只配置数据。
- **后果应用**： 根据选项定义的效果，事件系统调用不同模块接口实现。例如改变资源/属性：调用角色模块调整相应英雄属性或调用全局数据调整金币；给予奖励卡牌：调用卡牌模块将新卡加入某英雄牌组；触发战斗：则将控制权交给战斗系统生成一场战斗（比如选错选项遭遇埋伏）；解锁新路线：则通知地图模块在当前地图上开启新的节点或传送至隐藏地图。事件系统本身扮演协调者，根据配置决定把任务交给谁执行，并追踪**事件后续**。例如某些事件可能有后续情节，选择某选项会标记一个flag，后面另一个事件才会出现。事件系统需要保存这些全局flag（可存在游戏进度中），以实现**事件链**或**分支剧情**。
- **文本与本地化**： 事件系统管理大量文本，因此考虑本地化支持。事件定义可存文本ID，由本地化模块映射到不同语言以便将来支持多语言。Arc42文档中i18n是跨切面关注点，事件模块遵循这一点：文本与逻辑分离，方便后续翻译。

**设计示例**： 假设事件数据文件event_001.json定义：
{
  "id": 1,
  "description": "你在路边发现一个神秘宝箱。",
  "options": [
    { "id": "open", "text": "打开宝箱", "effects": ["give_item:Gold,50", "trigger_event:2"] },
    { "id": "ignore", "text": "无视离开", "effects": [] }
  ]
}
事件系统读取此数据，在地图节点触发时，通过UI显示描述和两个按钮“打开宝箱/无视离开”。如果玩家选择“打开宝箱”，事件系统解析effects列表：give_item:Gold,50意味着调用资源模块增加50金币，trigger_event:2表示立刻触发ID为2的事件（可能是宝箱陷阱事件）。事件系统于是继续加载事件2并重复呈现流程。若玩家选择“无视”，effects为空则什么也不发生，事件结束。整个过程中，事件系统发送EventOccurred、EventChoiceMade事件供日志或其它系统记录。

**扩展性**：
- **新增事件与剧情**： 由于采用数据驱动，增加事件只需编辑数据文件，不修改代码。可以持续丰富事件库。支持**剧情章节**扩展：例如未来添加新的剧情线，只要编写一系列事件并用条件和flag串联即可实现分支故事。当前架构支持事件之间通过flag关联，使深度剧情成为可能（在模块内部我们维护一个字典eventFlags存储已发生的重要事件标记）。
- **复杂选项逻辑**： 若未来需要更复杂的选项逻辑（如概率成功的检定，或基于英雄某属性决定结果），可扩展事件脚本语言的指令集。例如增加if条件判断：“if Hero[0].Agility > 5 then ...”。事件系统扩展解析器即可支持，无需影响其它模块。当前设计将事件效果解析独立出来，方便未来增强脚本能力（甚至可以考虑嵌入简易DSL或使用 Lua 脚本实现高复杂度事件）。
- **与其他系统协作**： 事件系统本身不执行具体效果，但可灵活调用其他模块。未来若新增**例如“解谜小游戏”**这样的特殊事件，可以在事件效果中增加类型“minigame:X”来触发。事件系统遇到此指令时，可以通知一个迷你游戏模块执行，并暂停主流程直至小游戏结果产生，再继续后续逻辑。这种协作通过事件总线或直接调用实现，新增模块只需在事件解析时挂接即可。

### 地图探索系统模块

**模块职责**：**地图系统管理冒险的关卡进程和地图结构**。它负责生成和呈现关卡地图、节点布局，并处理玩家在地图上的移动选择。地图系统串联战斗和事件模块，是游戏流程推进的框架。每个章节的地图可视为一个独立单元，地图系统负责在章节之间过渡和在全局记录进度。

**核心功能**：
- **关卡地图表示**： 定义数据结构表示地图节点及其连接关系。可以使用图结构：节点包含类型（战斗、事件、商店、营地等）、位置坐标（用于UI显示）、以及与其他节点的邻接关系。地图系统根据设计好的模板或程序生成算法构造地图。例如每章地图有固定的开始节点和终点首领节点，中间若干层次，玩家每完成一节点从当前层跳到下一层相邻节点。也可以采用**随机生成**：如从预定义的节点库中随机挑选组合，从而每次地图略有不同。
- **地图UI呈现**： 地图系统将地图数据传递给UI模块进行绘制。UI以节点图标和连线展示关卡布局，并高亮当前所在节点和可选路径。当玩家点击某相邻节点，UI调用地图系统的MoveToNode(targetNode)接口尝试移动。地图系统检查移动是否合法（是否相邻，是否当前节点事件处理完毕等），若合法则更新当前节点状态并触发该节点对应的场景。触发方式为：如果目标节点类型是战斗，则调用战斗系统初始化战斗；事件则调用事件系统显示事件；商店/营地则调用对应模块或UI显示。地图系统将自身置于等待，直到该节点场景完成（战斗胜利或事件结束），再继续接受玩家下一次移动选择。
- **章节与全局进度**： 地图系统管理章节切换逻辑。当当前地图终点（Boss节点）完成且胜利时，地图系统负责加载下一章节的地图数据（如果有）并重置队伍状态（例如在章节间可能有一次全队完全恢复或保留血量取决于设计）。如果已是最后一章且Boss战胜利，则通知游戏结束（胜利结局）；如果在某战斗失败，则通知游戏结束（失败结局）。地图系统通过事件发布这些全局结果，由上层游戏流程（可能是Game场景控制器）接收并做相应处理（如弹出结算界面，保存进度等）。
- **存档与加载**： 地图系统与数据存储结合，提供存档功能。由于关卡流程较长，需要支持在非战斗状态下保存当前进度。地图系统能够序列化当前状态（当前章节索引、当前节点ID、地图结构进展，比如已完成哪些节点、队伍状态等）并交由存储模块写入存档文件。加载时则从存档重建地图和队伍状态，允许玩家从中断处继续冒险。这涉及到与角色模块、卡牌模块协同重建对象。为简化，可以在每章节开始或结束时存档，或者仅在营地节点允许存档。

**设计示例**： MapManager类内部维护当前地图节点列表和指针currentNode。节点结构如：
class MapNode {
    public string id;
    public NodeType type; // Battle, Event, Shop, Camp, Boss etc.
    public List<MapNode> neighbors;
    public bool completed;
}
当玩家在UI选择前往某节点时，UI传入节点id给MapManager.MoveTo(nodeId)。方法检索目标节点，如果currentNode.neighbors包含它且currentNode处理完毕，则认为移动有效。然后根据节点类型执行：
•	if type == Battle → 调用BattleManager.StartBattle(enemyGroupId)，敌人配置可由节点附加的数据给出；
•	if type == Event → 调用EventManager.Trigger(eventId)，事件Id可预置在节点；
•	…依此类推。
同时设置currentNode = targetNode并标记状态。BattleManager和EventManager执行过程中，MapManager可以订阅它们的结束事件：如订阅BattleEnd，胜利则标记节点completed并继续，失败则通知Game Over；订阅EventEnd立即标记completed。若targetNode为Boss且战斗胜利，MapManager检查是否有下一章节，有则加载新地图（可能通过读取下一个关卡文件）并更新UI；无则发送AdventureComplete事件。

**扩展性**：
•	地图多样化： 采用数据驱动地图的方式易于扩展关卡内容。设计师可以绘制不同拓扑的地图（直线、分叉、网状等）并配置节点事件。为增加roguelike随机性，也可后续加入**地图随机生成算法**（例如节点随机取自模板池）。地图系统可提供挂钩，在每章节开始时调用特定函数生成地图。如果实现随机生成，只要结果符合节点和邻接结构，后续流程无需改变。
•	分支和隐藏路线： 未来剧情深度增加时，可在地图中预置**隐藏节点**或**分支条件**。地图系统可以根据全局事件flag决定是否解锁某隐藏节点邻接。例如某事件系统flag触发，则地图上出现隐藏Boss节点。当前架构允许在运行中修改地图数据结构（增加或启用节点），并通过事件通知UI刷新显示即可。
•	新节点类型： 若未来加入新功能节点（例如**商店**用于购物、**营地**用于休息回血、**剧情节点**用于过场对话），可以扩展NodeType枚举，并在MoveTo逻辑中增加对应分支。例如if type == Shop则暂停游戏并打开商店UI（商店UI操作商品购买通过资源模块实现）。这种增加不会影响已有节点流程。各模块职责清晰，可以各自扩充对应功能，然后由地图系统衔接调用。

---

## 扩展性与未来规划

本游戏架构在设计时充分考虑了未来功能扩展的需求，确保在当前单机版本的基础上，可以较为平滑地加入新特性而不破坏现有模块。以下列出几项重要的未来扩展方向及其与当前架构的衔接方式：

- **深度剧情与章节扩充**： 后续版本将增加更丰富的剧情内容，包括多章节主线故事和分支结局。借助**事件决策系统**的数据驱动设计，我们可以方便地添加成组的事件形成剧情线，并通过地图的多章节支持来组织故事进程。每章之间增加剧情过场（可通过特殊剧情节点或过场动画实现）。角色的选择将影响故事走向，我们已在事件系统中引入eventFlags机制记录关键抉择，从而在后续章节条件性地出现不同的事件或敌人。架构上，无需改变模块接口，只需丰富事件库和地图配置，即可实现复杂剧情。我们也计划在剧情层面引入**对白与过场**支持，可能通过在事件效果中增加“cutscene”类型或结合Godot的动画系统来实现。由于Arc42强调跨切面需求，我们也考虑**本地化**：未来若剧情文本庞大，多语言支持将通过事件文本ID映射来实现，目前的事件系统和UI已考虑这一点。深度剧情的扩展主要发生在内容层，框架已经准备好承载更复杂的故事线。

- **装备与物品系统**： 增加装备系统能丰富RPG养成元素，包括武器、防具、饰品，以及消耗品道具等。这部分扩展将通过**新增模块**来实现，但能无缝融入现有架构。我们将引入**物品管理模块**，负责定义物品属性和效果，并管理角色的背包/库存。角色模块已预留装备栏位，每件装备可以通过修改角色属性或在战斗中产生特殊效果（例如一把剑提高攻击力，一个护符在战斗开始时给予护盾等）。卡牌系统和战斗系统通过查询角色当前属性和状态，已经**隐含支持**了装备效果：装备影响属性，属性影响伤害和卡牌效果计算，所以很多情况下装备效果自动体现在战斗中。而对特殊效果（如战斗开始触发的装备技能），可以通过战斗系统在初始化英雄时检查其装备清单来添加对应Buff。物品使用（如消耗药水）可看作一张特殊的“道具卡牌”，玩家在非战斗界面使用时，事件系统可处理其效果（或者战斗中当作卡牌打出也由战斗系统处理）。因此，添加装备系统主要工作在于建立物品数据库、角色装备接口和UI展示，这些都可以独立于原有模块实现，然后利用原有事件/角色框架与之连接。
- **其他内容扩展**： 除上述主要方向外，架构还支持**更多英雄职业**、**更多卡牌和敌人**的平滑扩充。这些新增内容本质上是数据，框架通过工厂和配置模式容纳新内容。例如卡牌和敌人都是通过配置文件加载，添加新的只需提供数据和素材。战斗和事件机制也允许**新的玩法要素**加入，比如谜题解锁、领袖技能（在战斗或地图中触发全队增益）等，可通过组合现有模块或少量扩展实现。**性能优化**方面，框架使用C#脚本和Godot优化的渲染，已经在设计时考虑了高负载情况下的分层处理（如将频繁更新逻辑限制在需要的范围）。将来内容更多时，可进一步采用**多线程**（Godot 4 C# 支持线程）处理AI或粒子效果，或利用对象池优化卡牌与敌人对象的反复创建销毁。总之，当前系统在满足基本闭环功能的同时，为几乎所有预见的扩展方向都预留了接口或松耦合设计，这将确保产品能够**长期演进**而无技术债高筑。








