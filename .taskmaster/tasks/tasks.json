{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "设计并实现卡牌领域模型 (CardDefinition/CardInstance)",
        "description": "在 Game.Core/Domain 中创建卡牌核心数据结构,支持静态定义与运行时实例分离",
        "details": "创建 Game.Core/Domain/Card.cs:\n- CardDefinition: 卡牌静态配置(ID、名称、消耗、目标规则、效果指令列表、文本key、稀有度、职业标签)\n- CardInstance: 运行时卡牌实例(引用 CardDefinition、临时费用变化、回合内标记、升级状态)\n- TargetRule 枚举(SingleEnemy/AllEnemies/SingleAlly/AllAllies/Random)\n- CardType 枚举(Attack/Defense/Skill)\n效果指令使用 List<EffectCommand> 预留接口。使用 record 类型保证不可变性。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- CardDefinitionTests: 验证卡牌创建、字段验证、升级ID映射\n- CardInstanceTests: 验证临时状态修改、费用计算、标记管理\n覆盖率目标: lines ≥90%, branches ≥85%",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "定义卡牌属性与Immutable Record类型",
            "description": "创建CardDefinition和CardInstance的record类型,定义所有卡牌属性、枚举类型(CardType、TargetRule),使用record保证不可变性",
            "dependencies": [],
            "details": "在Game.Core/Domain/Card.cs中实现:\n- CardDefinition record: ID、名称、消耗、目标规则、效果指令列表、文本key、稀有度、职业标签、升级ID\n- CardInstance record: 引用CardDefinition、临时费用变化、回合内标记字典、升级状态\n- CardType枚举: Attack/Defense/Skill\n- TargetRule枚举: SingleEnemy/AllEnemies/SingleAlly/AllAllies/Random\n- EffectCommand接口预留(占位)\n参考Player.cs的record设计模式,确保所有字段为readonly属性",
            "status": "pending",
            "testStrategy": "xUnit单元测试CardDefinitionTests:\n- 验证CardDefinition创建与字段赋值\n- 验证CardInstance创建与引用关系\n- 验证枚举值的有效性\n- 测试record的不可变性(尝试修改字段应失败或返回新实例)"
          },
          {
            "id": "2",
            "title": "实现卡牌验证逻辑与工厂方法",
            "description": "为CardDefinition和CardInstance实现字段验证、工厂方法、升级映射逻辑,确保卡牌数据完整性",
            "dependencies": [
              "1"
            ],
            "details": "在Game.Core/Domain/Card.cs中添加:\n- CardDefinition验证方法:\n  - ValidateId(): ID非空且>0\n  - ValidateName(): 名称非空\n  - ValidateCost(): 消耗0-10范围\n  - ValidateEffectCommands(): 效果指令列表非空\n  - CreateOrThrow()工厂方法: 执行所有验证,验证失败抛出ArgumentException\n- CardInstance验证方法:\n  - ValidateUpgradeId(): 升级ID有效或为null\n  - CreateOrThrow(cardDefinition)工厂方法: 初始化临时费用(=原费用)、空标记字典、升级状态=false\n- 升级映射静态字典(预留升级ID对应关系示例)\n按照Player.cs的验证模式实现(先验证后返回结果或抛异常)",
            "status": "pending",
            "testStrategy": "xUnit单元测试CardDefinitionTests和CardInstanceTests:\n- CardDefinition验证:\n  - 测试有效参数创建成功\n  - 测试ID=0、名称空字符串、消耗>10时抛异常\n  - 测试效果指令列表为空时抛异常\n- CardInstance验证:\n  - 测试创建时临时费用继承CardDefinition费用\n  - 测试升级ID映射的有效性\n  - 测试临时标记初始为空字典\n- 升级状态修改后费用计算(涉及后续任务,占位验证)"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down this task with a focus on 设计并实现卡牌领域模型 (CardDefinition/CardInstance).",
        "updatedAt": null
      },
      {
        "id": "2",
        "title": "实现牌堆系统 (Deck/Hand/Discard/Exhaust)",
        "description": "实现卡牌堆操作逻辑,支持抽牌、弃牌、洗牌、移除、升级替换",
        "details": "创建 Game.Core/Domain/CardPile.cs:\n- DrawPile/Hand/DiscardPile/ExhaustPile 类(或统一 CardPile 类用 PileType 区分)\n- 操作方法:\n  - Draw(n): 抽 n 张牌,抽牌堆空时自动洗回弃牌堆\n  - Discard(cardId): 手牌 → 弃牌堆\n  - Exhaust(cardId): 移至消耗堆(战斗结束移除)\n  - Shuffle(): 洗牌(调用 RngService)\n  - AddCard(cardDef): 构筑时添加卡\n  - RemoveCard(cardId): 构筑时移除卡\n  - UpgradeCard(cardId): 替换为升级版ID\n使用现有 Services/EventBus 发布 CardDrawn/CardDiscarded 事件。\n\n注：以上 demo 代码依赖 Godot，仅参考数据结构与迁移流程，Core 保持纯 C#。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "xUnit 单元测试:\n- CardPileTests: 验证抽牌逻辑、洗牌可复现性(固定 Seed)、弃牌堆循环、手牌上限\n- 边界测试: 空牌堆抽牌、重复移除、升级不存在卡牌\n使用 Fake RngService Mock 保证可预测随机",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "实现卡牌堆基础数据结构与不可变操作",
            "description": "创建 Game.Core/Domain/CardPile.cs，实现统一的 CardPile 类与 PileType 枚举，支持 DrawPile/Hand/DiscardPile/ExhaustPile 四种堆类型。实现基础的不可变性设计（使用 record 类型或不可变集合），包括 AddCard、RemoveCard、UpgradeCard 等构筑时操作。",
            "dependencies": [
              "1"
            ],
            "details": "- 创建 PileType 枚举（DrawPile/Hand/DiscardPile/ExhaustPile）\n- 设计 CardPile 类：不可变集合存储卡牌列表、PileType 标识符、容量限制\n- 实现基础方法：AddCard(cardDef) 返回新实例、RemoveCard(cardId) 返回新实例、UpgradeCard(cardId) 替换卡牌定义\n- 手牌容量限制逻辑（默认 10 张）\n- 使用 xUnit + NSubstitute 编写单元测试：验证加牌、移除、升级的不可变性与状态正确性\n- 覆盖边界情况：空堆操作、重复移除、升级非存在卡牌",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：CardPileTests 验证 AddCard/RemoveCard/UpgradeCard 逻辑、容量限制、不可变性；边界测试覆盖空堆、重复操作、无效 ID"
          },
          {
            "id": "2",
            "title": "实现洗牌、抽牌、归还卡牌的业务逻辑与事件发布",
            "description": "为 CardPile 类添加核心游戏逻辑方法：Shuffle(RngService)、Draw(n)、Discard(cardId)、Exhaust(cardId)、ReturnDiscardToDraw()。集成 EventBus 发布 CardDrawn/CardDiscarded 事件，实现抽牌堆耗尽时自动洗回弃牌堆的循环机制。",
            "dependencies": [
              "1"
            ],
            "details": "- 添加 Shuffle() 方法：调用 RngService.Shuffle() 打乱 DrawPile，返回新实例\n- 实现 Draw(n) 方法：从 DrawPile 抽 n 张牌至 Hand，抽牌堆不足时自动调用 ReturnDiscardToDraw() 并继续抽牌\n- 实现 Discard(cardId) 方法：从 Hand 移至 DiscardPile，发布 CardDiscarded 事件\n- 实现 Exhaust(cardId) 方法：从 Hand 移至 ExhaustPile（战斗结束清空）\n- 实现 ReturnDiscardToDraw() 方法：洗回弃牌堆至 DrawPile\n- 集成 IEventBus 发布 CardDrawn(cardId, drawOrder) 与 CardDiscarded(cardId) 事件\n- xUnit 单元测试：使用 Fake RngService Mock 验证抽牌逻辑、洗牌可复现性（固定 Seed）、弃牌堆循环、事件发布正确性\n- 性能测试：验证大规模抽牌（100+ 张）的性能",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：CardPileTests 验证 Draw/Discard/Exhaust/Shuffle 逻辑、弃牌堆循环、事件发布；使用 Fake RngService 保证洗牌可复现性；边界测试覆盖连续抽牌超出容量、重复洗牌、空堆循环"
          }
        ],
        "adrRefs": [
          "ADR-0004",
          "ADR-0011",
          "ADR-0018",
          "ADR-0020",
          "ADR-0021",
          "ADR-0022",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH04",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down this task with a focus on 实现牌堆系统 (Deck/Hand/Discard/Exhaust).",
        "updatedAt": null
      },
      {
        "id": "3",
        "title": "创建统一效果系统 (EffectResolver)",
        "description": "实现数据驱动的效果指令解析与执行引擎,复用于卡牌/事件/意图/奖励",
        "details": "创建 Game.Core/Services/EffectResolver.cs:\n- 定义效果指令基类 EffectCommand (抽象类或接口):\n  - DamageCommand(targetId, amount, damageType)\n  - GainBlockCommand(targetId, amount)\n  - HealCommand(targetId, amount)\n  - ApplyStatusCommand(targetId, statusId, stacks, duration)\n  - DrawCommand(heroId, count)\n  - ChangeEnergyCommand(heroId, delta)\n  - GainGoldCommand(amount)\n  - AddCardToDeckCommand(heroId, cardId)\n  - RemoveCardFromDeckCommand(heroId, cardId)\n  - UpgradeCardCommand(heroId, cardId)\n  - TriggerBattleCommand(encounterId)\n  - SetFlagCommand(flagId, value)\n- ExecuteEffect(cmd, context): 单条指令执行入口\n- ExecuteEffects(List<cmd>, context): 批量执行并触发事件\n使用 BattleContext 传递战斗状态引用。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- EffectResolverTests: 每种指令单独验证(Damage扣血、Block加盾、Heal回血等)\n- 组合测试: 多指令序列、目标校验、状态交互\n- Mock BattleContext 与 StatusManager 保证隔离",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "定义 EffectCommand 接口与基础命令类型",
            "description": "设计抽象的效果指令接口,实现 DamageCommand、GainBlockCommand、HealCommand 等11个具体命令类。每个命令包含必要字段与验证逻辑,确保参数有效性。",
            "dependencies": [],
            "details": "在 Game.Core/Services/EffectResolver.cs 中定义:\n- EffectCommand 抽象基类或接口,包含 Execute(BattleContext) 方法\n- 11个命令类: DamageCommand、GainBlockCommand、HealCommand、ApplyStatusCommand、DrawCommand、ChangeEnergyCommand、GainGoldCommand、AddCardToDeckCommand、RemoveCardFromDeckCommand、UpgradeCardCommand、TriggerBattleCommand、SetFlagCommand\n- 每个命令类使用 record 类型,包含命令特定参数(targetId/amount/damageType 等)\n- 添加基础验证: targetId 非空、amount > 0 等\n- 编写 xUnit 单测验证各命令的参数有效性与字段映射",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EffectCommandTests: 验证每种命令的构造、参数校验、字段正确性\n- 覆盖: DamageCommand(amount > 0)、GainBlockCommand(非负)、ApplyStatusCommand(duration 合法性)等\n- 使用 FluentAssertions 断言参数"
          },
          {
            "id": "2",
            "title": "实现 BattleContext 与参数绑定机制",
            "description": "构建执行上下文类 BattleContext,定义符号表与参数解析机制。支持从上下文中动态获取目标单位、状态管理器等依赖,实现命令参数与运行时状态的绑定。",
            "dependencies": [
              "1"
            ],
            "details": "在 Game.Core/Services/EffectResolver.cs 或新增 Game.Core/Services/BattleContext.cs:\n- BattleContext 类: 包含 CurrentHero、Enemies、StatusManager、EventBus、RngService 等引用\n- 符号表(Dictionary<string, object>): 支持 ${targetId}、${amount} 等占位符解析\n- 参数绑定方法: ResolveParameter(paramName) 返回实际值\n- 单位查询接口: GetUnit(unitId)、GetAllEnemies() 等\n- 编写 xUnit 单测验证上下文的初始化、参数解析、单位查询的正确性",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- BattleContextTests: 验证上下文初始化、符号表绑定、参数解析\n- 参数解析测试: ${targetId} → 实际单位 ID、${amount} → 数值\n- Mock Hero、StatusManager、EventBus 保证隔离\n- 覆盖边界: 无效 unitId、缺失符号等"
          },
          {
            "id": "3",
            "title": "实现效果执行引擎与错误处理",
            "description": "核心实现 ExecuteEffect 与 ExecuteEffects 方法,支持单条与批量指令执行。集成 EventBus 发布效果事件,添加完整错误处理与日志记录,确保失败时优雅退出与状态一致性。",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "在 Game.Core/Services/EffectResolver.cs:\n- ExecuteEffect(cmd, context): 单条指令执行入口\n  - 前置条件检查(目标存在、参数有效)\n  - 调用 cmd.Execute(context)\n  - 捕获异常,发布失败事件到 EventBus\n  - 返回 EffectResult(success, message)\n- ExecuteEffects(List<cmd>, context): 批量执行\n  - 遍历指令列表,逐条执行\n  - 任意指令失败时: 选择 ContinueOnError 还是立即中止(可配)\n  - 发布 EffectsExecuted 事件,包含执行结果摘要\n  - 返回 List<EffectResult>\n- 错误处理: 捕获 InvalidOperationException、ArgumentException 等,记录详细日志\n- EventBus 集成: 发布 EffectExecuted、EffectFailed、EffectsCompleted 等事件\n- 编写 xUnit 单测覆盖成功/失败/部分失败场景",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EffectResolverTests: 单条效果执行成功与失败\n- 批量执行测试: 多指令序列、中途失败、错误恢复\n- Mock EventBus: 验证事件发布顺序与内容\n- Mock 各命令的 Execute 方法: 模拟成功/异常\n- 错误处理测试: 无效目标、参数校验失败\n- 状态一致性: 确保失败时状态回滚或明确记录"
          },
          {
            "id": "4",
            "title": "编写复杂效果组合单元测试与集成验证",
            "description": "全面覆盖多指令组合、状态交互、目标校验等复杂场景。验证效果执行与 StatusManager、Hero 的协作,确保边界情况处理正确。提升单元测试覆盖率达到 lines ≥90%、branches ≥85%。",
            "dependencies": [
              "1",
              "2",
              "3"
            ],
            "details": "在 Game.Core.Tests/Services/EffectResolverTests.cs:\n- 单效果验证(已覆盖): Damage、GainBlock、Heal、ApplyStatus、Draw 等各命令\n- 复杂组合测试:\n  - Sequence1: ApplyStatus(Weak) → Damage(amount=10) → 验证伤害减少\n  - Sequence2: Damage → ApplyStatus(Poison) → TurnStart → 验证毒伤触发与衰减\n  - Sequence3: GainBlock → Damage → 验证护盾优先级\n  - Sequence4: DrawCommand → 验证抽牌数与手牌上限交互\n- 目标校验:\n  - SingleEnemy 指令指向不存在的敌人 → 失败并发布事件\n  - AllEnemies 指令 → 影响所有敌人\n- Mock StatusManager、Hero、EventBus 保证测试隔离\n- 边界情况: 空指令列表、null 参数、重复目标\n- 使用 xUnit 的 Theory + InlineData 参数化测试多组合\n- 覆盖率达成: 利用代码覆盖工具(coverlet)生成报告,补充缺失的分支",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EffectResolverIntegrationTests: 多指令组合、效果链式反应\n- Theory 参数化测试: 不同伤害值、状态叠加、目标组合\n- Mock StatusManager: 验证状态修改回调触发\n- Mock Hero: 验证 HP、Shield、Statuses 的变化\n- 边界与异常: null 输入、空列表、重复指令\n- 覆盖率目标: lines ≥90%, branches ≥85%\n- 使用 coverlet 收集覆盖率数据并生成报告到 logs/unit/"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on 创建统一效果系统 (EffectResolver).",
        "updatedAt": null
      },
      {
        "id": "4",
        "title": "设计状态系统 (StatusManager)",
        "description": "实现战斗状态(Buff/Debuff)的叠加、衰减、结算机制",
        "details": "创建 Game.Core/Domain/Status.cs 和 Game.Core/Services/StatusManager.cs:\n- StatusDefinition: 状态静态配置(ID、名称、结算时机、叠加规则、UI图标key)\n- StatusInstance: 运行时状态(statusId、stacks、duration、ownerUnitId)\n- 最小状态集合:\n  - Strength(力量): 造成伤害 +X\n  - Weak(虚弱): 造成伤害 -Y\n  - Vulnerable(易伤): 受到伤害 +Z%\n  - Poison(中毒): 回合开始结算伤害并衰减\n  - Block(护盾): 抵挡伤害(回合结束清零)\n- 结算时机:\n  - TurnStart: 中毒结算、回合开始衰减\n  - TurnEnd: 护盾清零、持续回合数衰减\n  - OnDealDamage: 力量/虚弱修正\n  - OnTakeDamage: 易伤修正\n叠加规则: stacks 相加,duration 取最大值。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- StatusManagerTests: 验证状态叠加、衰减、结算时机触发\n- 伤害修正测试: 力量/虚弱/易伤数值计算\n- 中毒测试: 回合开始伤害与 stacks 衰减\n- 护盾测试: 回合结束清零逻辑",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "实现状态数据结构与基础操作",
            "description": "创建 StatusDefinition 和 StatusInstance 数据结构，实现状态叠加(stacks相加、duration取最大值)与衰减逻辑",
            "dependencies": [],
            "details": "在 Game.Core/Domain/Status.cs 中定义：\n- StatusDefinition: 状态ID、名称、结算时机(turn_start_settlement/turn_end_settlement/OnDealDamage/OnTakeDamage)、叠加规则、UI图标key\n- StatusInstance: statusId、stacks、duration、ownerUnitId、应用时间\n- StatusManager.ApplyStatus(targetId, statusId, stacks, duration): 实现stacks相加、duration取最大值的叠加逻辑\n- StatusManager.DecayStatus(statusId): 衰减duration，当duration≤0时移除\n使用 record 类型保证不可变性，考虑使用值对象模式。验证状态ID存在性与参数有效范围",
            "status": "pending",
            "testStrategy": "xUnit单元测试 StatusManagerTests：\n- 测试新应用状态创建\n- 测试相同状态叠加(stacks累加、duration取max)\n- 测试不同状态共存\n- 边界测试：stacks溢出、负duration、无效statusId\n覆盖率目标 ≥90% lines, ≥85% branches"
          },
          {
            "id": "2",
            "title": "实现 turn_start_settlement 结算时机",
            "description": "实现中毒伤害结算与回合开始衰减逻辑，包括中毒伤害计算、stacks衰减与 statusId 映射",
            "dependencies": [
              "1"
            ],
            "details": "在 StatusManager 中实现 ResolveTurnStart(targetId) 方法：\n- 遍历目标单位的所有 StatusInstance\n- 对于 Poison(statusId=poison_def_id) 状态：\n  - 计算伤害 = base_damage × stacks（或配置值）\n  - 调用 EffectResolver.Execute(new DamageCommand(targetId, damage, 'poison'))\n  - stacks -= 1，duration不变\n  - 当 stacks ≤ 0 时移除该状态\n- 对于其他标记为 turn_start_settlement 的状态：执行相应衰减（如持续时间-1）\n- 发送 StatusResolved 事件，包含目标ID、状态ID、结算结果\n- 考虑多个同类状态的处理顺序（优先级）",
            "status": "pending",
            "testStrategy": "xUnit单元测试：\n- 测试中毒单独结算：伤害正确计算、stacks衰减、移除条件\n- 测试中毒叠加后结算：damage = base × stacks\n- 测试混合状态场景：中毒 + 力量同时触发 turn_start_settlement\n- 测试边界：poison stacks=1衰减后移除、无poison状态调用\n- Mock EffectResolver 验证 DamageCommand 正确调用\n使用固定种子数据保证结果可复现"
          },
          {
            "id": "3",
            "title": "实现 turn_end_settlement 结算时机",
            "description": "实现护盾清零与持续回合数衰减逻辑，包括回合结束的多种状态清理规则",
            "dependencies": [
              "1"
            ],
            "details": "在 StatusManager 中实现 ResolveTurnEnd(targetId) 方法：\n- 遍历目标单位的所有 StatusInstance\n- 对于 Block(护盾, statusId=block_def_id) 状态：\n  - 直接移除该状态（回合结束护盾清零）\n  - 发送 BlockCleared 事件，包含清除前的护盾值\n- 对于其他标记为 turn_end_settlement 的持续状态：\n  - duration -= 1\n  - 当 duration ≤ 0 时移除状态\n- 对于需要衰减但无特殊时机的状态（如 Strength/Weak）：\n  - 如果配置为 turn_end_settlement 衰减，duration -= 1\n- 发送 TurnEndResolved 事件，包含所有已清理状态列表\n- 考虑清理顺序与事件发送时机",
            "status": "pending",
            "testStrategy": "xUnit单元测试：\n- 测试护盾清零：任何护盾值都在回合结束完全移除\n- 测试持续状态衰减：duration逐回合递减、为0时移除\n- 测试多个状态混合：护盾清零、其他状态衰减、部分状态保留\n- 测试边界：duration=1时衰减至0并移除、无状态调用\n- Mock EffectResolver 和 StatusManager 之间的隔离\n- 验证事件发送顺序与内容正确性"
          },
          {
            "id": "4",
            "title": "实现伤害修正与数值计算验证",
            "description": "实现 OnDealDamage 和 OnTakeDamage 时机的伤害修正，包括力量/虚弱/易伤的准确数值计算",
            "dependencies": [
              "1"
            ],
            "details": "在 StatusManager 中实现两个计算方法：\n- CalcDealDamage(damageAmount, sourceUnitId) → adjustedDamage：\n  - 检查源单位是否有 Strength(statusId=strength_def_id)：damage += strength_value × stacks\n  - 检查源单位是否有 Weak(statusId=weak_def_id)：damage -= weak_value × stacks\n  - 返回调整后的伤害值（最小≥1）\n- CalcTakeDamage(damageAmount, targetUnitId) → adjustedDamage：\n  - 检查目标单位是否有 Vulnerable(statusId=vulnerable_def_id)：damage × (100% + vulnerable_percentage × stacks)\n  - 返回调整后的伤害值\n- 在 EffectResolver.Execute(DamageCommand) 中集成这两个方法\n- 确保计算顺序：先apply source修正，再apply target修正\n- 处理浮点数舍入（建议向下取整或四舍五入）\n- 记录修正前后值用于日志与调试",
            "status": "pending",
            "testStrategy": "xUnit单元测试，验证精确数值计算：\n- Strength修正：damage=10 + strength_value×stacks，多个stacks场景\n- Weak修正：damage减少weak_value×stacks，验证不低于1\n- Vulnerable修正：damage×(100%+25%×stacks)，验证百分比计算\n- 组合修正：source有Strength+target有Vulnerable的完整流程\n- 边界值：damage=0/1、stacks=0、多个同类status\n- 伤害下限验证：修正后damage≥1（不能为负或0）\n创建专用 StatusCalculationTests 类，使用参数化测试覆盖10+场景组合"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on 设计状态系统 (StatusManager).",
        "updatedAt": null
      },
      {
        "id": "5",
        "title": "实现英雄领域模型 (Hero)",
        "description": "创建英雄实体,支持属性、牌组、战斗临时状态管理",
        "details": "创建 Game.Core/Domain/Hero.cs:\n- 基础属性:\n  - HeroId、Name、ClassId(职业)\n  - MaxHealth、CurrentHealth\n  - BaseEnergyMax(每回合刷新)\n  - CurrentEnergy(战斗临时)\n  - BaseAttack/BaseDefense(可选,T2弱化)\n- 牌组引用: Deck/Hand/Discard/Exhaust(组合 CardPile)\n- 战斗临时状态:\n  - Shield(护盾)\n  - Statuses: List<StatusInstance>\n- 方法:\n  - TakeDamage(amount): 优先扣护盾再扣生命\n  - Heal(amount): 回血(不超过上限)\n  - GainShield(amount): 加护盾\n  - RefreshEnergy(): 回合开始重置能量\n  - ClearCombatState(): 战斗结束清除临时状态(保留 HP)\n继承或使用现有 Player 类,扩展卡牌相关字段。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- HeroTests: 验证 TakeDamage 护盾优先级、Heal 上限限制、能量刷新\n- 状态集成测试: ApplyStatus → TakeDamage 验证易伤/护盾交互\n- ClearCombatState: 验证战斗结束状态清空但 HP 保留",
        "priority": "high",
        "dependencies": [
          "2",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "定义英雄属性与职业体系",
            "description": "创建 Hero.cs 基础类,定义英雄属性、职业系统、生命与能量机制",
            "dependencies": [],
            "details": "在 Game.Core/Domain/Hero.cs 中实现:\n1. HeroId、Name、ClassId(职业枚举) 属性\n2. MaxHealth、CurrentHealth 与 MaxEnergy、CurrentEnergy 属性\n3. 职业枚举 HeroClass(Warrior/Mage/Rogue等)\n4. 初始化构造函数与属性验证(HP>0、Energy>=0)\n5. 编写 xUnit 测试验证属性初始化与约束条件\n不实现卡牌相关,仅聚焦属性定义与职业体系。",
            "status": "pending",
            "testStrategy": "xUnit: HeroTests - 验证属性初始化、约束检查(负数拒绝)、职业枚举映射"
          },
          {
            "id": "2",
            "title": "实现卡牌堆与战斗临时状态管理",
            "description": "集成 CardPile、Shield、StatusInstance 到 Hero,实现战斗状态维护",
            "dependencies": [
              "1"
            ],
            "details": "扩展 Hero.cs:\n1. 添加 Deck/Hand/Discard/Exhaust 四个 CardPile 属性\n2. 添加 Shield 属性(护盾值)\n3. 添加 Statuses: List<StatusInstance> 列表\n4. 初始化方法验证卡牌堆不为 null\n5. ClearCombatState() 方法: 清空 Shield/Statuses,保留 HP\n6. 编写 xUnit 测试验证状态初始化与清空逻辑\n依赖现有 CardPile.cs 与 StatusInstance 实现。",
            "status": "pending",
            "testStrategy": "xUnit: HeroStateTests - 验证状态初始化、ClearCombatState 保留 HP、Shield/Statuses 清空"
          },
          {
            "id": "3",
            "title": "实现伤害/治疗/护盾机制与回合刷新",
            "description": "实现 Hero 的 TakeDamage/Heal/GainShield/RefreshEnergy 核心方法",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "实现 Hero.cs 核心方法:\n1. TakeDamage(amount): 优先扣护盾,护盾不足则扣生命(不低于0)\n2. Heal(amount): 回血至 MaxHealth 上限\n3. GainShield(amount): 累加护盾值\n4. RefreshEnergy(): 重置 CurrentEnergy = MaxEnergy(回合开始)\n5. 集成 EventBus 发布 HeroHealthChanged/ShieldChanged/EnergyRefreshed 事件\n6. 编写 xUnit 单元测试覆盖所有方法与边界条件(伤害为0、过度治疗、负数拒绝)\n覆盖率目标: lines ≥90%, branches ≥85%。",
            "status": "pending",
            "testStrategy": "xUnit: HeroCombatTests - 验证 TakeDamage 护盾优先级、Heal 上限、RefreshEnergy、事件发布;边界测试:负数、零值、超限"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on 实现英雄领域模型 (Hero).",
        "updatedAt": null
      },
      {
        "id": "6",
        "title": "实现敌人领域模型 (Enemy/EnemyAI)",
        "description": "创建敌人实体与意图生成逻辑",
        "details": "创建 Game.Core/Domain/Enemy.cs:\n- 基础属性:\n  - EnemyId、Name、EncounterId\n  - MaxHealth、CurrentHealth、Shield\n  - Statuses: List<StatusInstance>\n- 意图系统:\n  - Intent: 下一回合动作预告(IntentType、TargetId、EffectCommands)\n  - IntentType 枚举(Attack/Defend/Buff/Debuff/Special)\n  - GenerateIntent(): 根据简单 AI 表生成下一回合动作\n- 方法: TakeDamage/Heal/GainShield(与 Hero 复用或抽象基类 CombatUnit)\n创建 Game.Core/Services/EnemyAI.cs:\n- IntentTable: 敌人技能序列定义(循环/条件触发)\n- GenerateIntent(enemy, battleContext): 最小实现为顺序循环技能表。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- EnemyTests: 验证 TakeDamage、状态管理\n- EnemyAITests: 验证意图生成可预测性(固定技能表 → 固定意图序列)\n- Intent 结构测试: 验证 EffectCommands 可序列化与执行",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "实现Enemy值对象和属性定义",
            "description": "创建 Game.Core/Domain/Enemy.cs 类,定义敌人基础属性(EnemyId、Name、EncounterId、MaxHealth、CurrentHealth、Shield)和Statuses列表,以及TakeDamage/Heal/GainShield方法。可选:抽象CombatUnit基类供Hero复用。",
            "dependencies": [
              "4"
            ],
            "details": "实现要点:(1) Enemy 类使用 record 保证不可变属性;(2) 属性包括:EnemyId(string/Guid)、Name(string)、EncounterId(string)、MaxHealth(int)、CurrentHealth(int)、Shield(int)、Statuses(List<StatusInstance>);(3) 方法 TakeDamage(int amount):减少CurrentHealth,处理防护盾;Heal(int amount):增加CurrentHealth,不超过MaxHealth;GainShield(int amount):增加Shield;(4) 考虑与Hero共用的抽象基类CombatUnit(health、shield、statuses),Enemy和Hero继承;(5) xUnit测试验证属性初始化、TakeDamage逻辑(扣血、盾值扣减)、Heal上限、Shield独立计算。",
            "status": "pending",
            "testStrategy": "xUnit单元测试EnemyTests:验证构造函数、TakeDamage(shield优先、溅伤到血量)、Heal(上限检查)、GainShield,测试覆盖lines≥90%"
          },
          {
            "id": "2",
            "title": "设计IAIStrategy接口和意图系统",
            "description": "创建 Game.Core/Contracts/IAIStrategy 接口和 Intent 数据结构,定义 IntentType 枚举(Attack/Defend/Buff/Debuff/Special),实现Enemy.GenerateIntent() 方法与 EnemyAI.cs 基础框架。",
            "dependencies": [
              "1"
            ],
            "details": "实现要点:(1) 创建 Game.Core/Contracts/IAIStrategy.cs 接口,方法 GenerateIntent(Enemy enemy, BattleContext context):Intent;(2) 创建 Intent record 类:包含IntentType、TargetId(string)、EffectCommands(List<IEffectCommand>)、Priority(int 用于排序);(3) IntentType 枚举定义Attack、Defend、Buff、Debuff、Special五种;(4) Enemy 类增加 GenerateIntent(IAIStrategy strategy, BattleContext context):Intent 方法;(5) 创建 Game.Core/Services/EnemyAI.cs 与 IntentTable 类定义敌人技能序列(数组或列表形式,支持循环和条件触发占位);(6) xUnit 测试验证 Intent 结构可序列化、EffectCommands 列表完整性、IAIStrategy 接口实现。",
            "status": "pending",
            "testStrategy": "xUnit单元测试IntentTests:验证Intent数据结构、IntentType枚举、序列化反序列化;EnemyAITests:验证GenerateIntent返回正确的Intent类型和TargetId"
          },
          {
            "id": "3",
            "title": "实现简单和复杂AI策略",
            "description": "创建至少两个 IAIStrategy 实现:SimpleAI(循环技能表)和 PriorityAI(基于条件的优先级决策),包含 IntentTable 解析和决策逻辑。",
            "dependencies": [
              "2"
            ],
            "details": "实现要点:(1) SimpleAI 类:循环遍历敌人的 IntentTable,返回下一个技能的 Intent,记录当前索引,循环回轮;(2) PriorityAI 类:根据敌人血量、Shield、Statuses 状态和 BattleContext(英雄血量、阵容)评估优先级,从 IntentTable 中选择最高优先级技能;(3) IntentTable 数据结构包含敌人可用技能列表及其优先级权重;(4) 支持条件触发(如血量<50%时优先防御);(5) xUnit 测试验证:SimpleAI 固定技能表→固定意图序列、PriorityAI 在不同 BattleContext 下选择不同技能、决策逻辑的确定性与一致性。",
            "status": "pending",
            "testStrategy": "xUnit单元测试AIStrategyTests:SimpleAI循环顺序正确、PriorityAI基于健康值和状态的决策逻辑正确、条件触发生效;覆盖lines≥90%"
          },
          {
            "id": "4",
            "title": "xUnit单元测试与集成测试验证",
            "description": "编写完整的xUnit单测覆盖Enemy类、Intent结构、IAIStrategy接口及各实现,验证意图生成的可预测性、EffectCommands执行链、与StatusManager的交互。",
            "dependencies": [
              "3"
            ],
            "details": "实现要点:(1) EnemyTests:验证Enemy属性初始化、TakeDamage(包含Shield)、Heal、GainShield、Statuses列表管理;(2) IntentTests:验证Intent record 结构、字段完整性、序列化与反序列化(JSON);(3) SimpleAITests:验证固定技能表循环生成意图序列、多轮一致性;(4) PriorityAITests:验证不同 BattleContext 下的优先级计算、条件触发的准确性;(5) EnemyAI集成测试:模拟战斗场景,验证 EnemyAI.GenerateIntent() 多次调用的可预测性;(6) EffectCommands 可序列化与执行链测试(预留接口);(7) 覆盖率目标 lines≥90%, branches≥85%;(8) 使用 NSubstitute Mock BattleContext 和 StatusManager;使用 Xunit 的 Fact 和 Theory 参数化测试。",
            "status": "pending",
            "testStrategy": "xUnit单元测试+集成测试:EnemyTests、IntentTests、AIStrategyTests(Simple和Priority)、EnemyAIIntegrationTests;覆盖意图生成的可预测性、多轮一致、EffectCommands完整性;覆盖率lines≥90%,branches≥85%;使用NSubstitute和FluentAssertions"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on 实现敌人领域模型 (Enemy/EnemyAI).",
        "updatedAt": null
      },
      {
        "id": "7",
        "title": "创建战斗状态机 (BattleManager)",
        "description": "实现回合制战斗核心状态机,管理阶段推进与胜负判定",
        "details": "创建 Game.Core/Services/BattleManager.cs:\n- 战斗阶段枚举:\n  - core.battle.started → core.battle.turn.player.started → PlayerMain → core.battle.turn.enemy.started → EnemyTurn → (循环或胜负)\n- 核心方法:\n  - StartBattle(heroes, enemies): 初始化战斗,清空临时状态,生成敌人初始意图\n  - StartPlayerTurn(): 刷新能量、抽牌、结算 turn_start_settlement 状态\n  - PlayCard(heroId, cardId, targetId): 校验能量/目标,执行卡牌 EffectCommands,扣能量,移牌\n  - EndPlayerTurn(): 弃手牌,结算 turn_end_settlement 状态(护盾清零),刷新敌人意图\n  - ExecuteEnemyTurn(): 遍历敌人执行意图(复用 EffectResolver)\n  - CheckVictory(): 敌方全灭 → core.battle.ended\n  - CheckDefeat(): 我方全灭 → core.battle.ended\n- 任意单位 HP ≤ 0 时立即触发死亡处理与胜负检查。\n发布事件: BattleStarted/PlayerTurnStarted/CardPlayed/core.effect.resolved/UnitDied/core.battle.ended/core.battle.ended。\n\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "xUnit 单元测试:\n- BattleManagerTests: 验证状态机推进顺序、回合能量刷新、抽牌数量\n- PlayCard 测试: 能量不足拒绝、目标非法拒绝、成功出牌后能量扣除\n- 胜负判定: 敌方全灭触发 core.battle.ended、我方全灭触发 core.battle.ended\n- 状态结算: turn_start_settlement 中毒结算、turn_end_settlement 护盾清零\n使用 Mock StatusManager 和 EffectResolver 隔离依赖",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "实现战斗初始化与阶段状态机",
            "description": "创建 BattleManager 类的核心框架，实现战斗阶段枚举、初始化逻辑和状态机推进机制，确保回合顺序正确流转。",
            "dependencies": [],
            "details": "在 Game.Core/Services/BattleManager.cs 中：\n1. 定义 BattlePhase 枚举（core.battle.started、core.battle.turn.player.started、PlayerMain、core.battle.turn.enemy.started、EnemyTurn、core.battle.ended、core.battle.ended）\n2. 创建 BattleManager 类，持有当前阶段状态、英雄列表、敌人列表\n3. 实现 StartBattle(heroes, enemies) 方法：初始化单位、清空临时状态、生成敌人初始意图、发布 BattleStarted 事件\n4. 实现 StartPlayerTurn() 方法：刷新能量、抽牌、结算 turn_start_settlement 状态\n5. 编写状态机推进逻辑，确保相邻阶段正确过渡\n6. 使用 xUnit 验证状态机推进顺序、初始化后能量/手牌正确性",
            "status": "pending",
            "testStrategy": "xUnit 单元测试验证：StartBattle 初始化英雄/敌人、能量回满、抽卡数量正确；StartPlayerTurn 能量值变化；状态机顺序推进"
          },
          {
            "id": "2",
            "title": "实现玩家回合处理（出牌与结算）",
            "description": "完成玩家回合的核心逻辑，包括卡牌出牌校验、能量扣除、效果执行以及回合结束的状态结算。",
            "dependencies": [
              "1"
            ],
            "details": "在 Game.Core/Services/BattleManager.cs 中：\n1. 实现 PlayCard(heroId, cardId, targetId) 方法：\n   - 校验当前阶段是否为 PlayerMain\n   - 校验英雄是否拥有该卡牌、能量是否充足、目标是否合法\n   - 调用 EffectResolver 执行卡牌效果指令\n   - 扣除英雄能量、将卡牌移至弃牌堆、发布 CardPlayed 事件\n2. 实现 EndPlayerTurn() 方法：\n   - 弃掉手牌剩余卡牌\n   - 结算 turn_end_settlement 状态（护盾清零、衰减计数）\n   - 调用 GenerateEnemyIntentions 刷新敌人意图\n   - 转移至 EnemyTurn 阶段\n3. 使用 Mock StatusManager 和 EffectResolver 隔离依赖\n4. 编写 xUnit 测试验证出牌流程、能量扣除、非法操作拒绝",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：能量不足拒绝出牌、目标非法拒绝出牌、成功出牌后能量扣除、状态结算触发、手牌弃掉"
          },
          {
            "id": "3",
            "title": "实现敌方回合处理与意图执行",
            "description": "完成敌人回合的意图生成与执行逻辑，复用 EffectResolver 执行意图中的效果指令，完成敌人整体行动。",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "在 Game.Core/Services/BattleManager.cs 中：\n1. 实现 ExecuteEnemyTurn() 方法：\n   - 遍历当前阵营中所有活着的敌人\n   - 对每个敌人，获取其预生成的 Intention（包含目标和效果指令列表）\n   - 调用 EffectResolver 执行 Intention 中的所有效果指令\n   - 为下一敌人回合生成新意图或继续使用既有意图\n   - 发布敌人行动相关事件（UnitActed 等）\n2. 实现 GenerateEnemyIntentions() 方法：\n   - 遍历敌人，根据其 AI 策略生成下一回合的意图\n   - 存储在敌人单位的临时意图槽位\n3. 编写状态结算逻辑，确保敌人行动后触发 OnTakeDamage 等状态时机\n4. 使用 Mock EffectResolver 验证意图执行流程\n5. 编写 xUnit 测试验证敌人意图执行、敌人伤害正确应用",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：验证敌人意图遍历执行、每个敌人意图只执行一次、EffectResolver 被正确调用、敌人伤害应用到英雄"
          },
          {
            "id": "4",
            "title": "实现战斗胜负判定与结束善后",
            "description": "完成战斗结束条件判定，处理单位死亡触发、胜负判定、事件发布以及战斗后清理逻辑。",
            "dependencies": [
              "1",
              "2",
              "3"
            ],
            "details": "在 Game.Core/Services/BattleManager.cs 中：\n1. 实现 CheckVictory() 方法：\n   - 检查是否所有敌人 HP ≤ 0\n   - 若满足，转移至 core.battle.ended 阶段、发布 core.battle.ended 事件、返回 true\n2. 实现 CheckDefeat() 方法：\n   - 检查是否所有英雄 HP ≤ 0\n   - 若满足，转移至 core.battle.ended 阶段、发布 core.battle.ended 事件、返回 true\n3. 在 EffectResolver 执行伤害后调用死亡判定：\n   - 若任意单位 HP ≤ 0，触发 OnUnitDied 事件、移除该单位、立即检查胜负\n4. 实现战斗清理逻辑：\n   - 清空临时状态（意图、能量临时修正等）\n   - 保留永久状态（等级、金币等）用于后续奖励结算\n5. 编写 xUnit 测试验证胜利/失败条件、死亡处理、事件发布顺序",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：敌方全灭触发 core.battle.ended、我方全灭触发 core.battle.ended、单位 HP ≤ 0 立即死亡、胜负检查优先级正确、事件发布顺序"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on 创建战斗状态机 (BattleManager).",
        "updatedAt": null
      },
      {
        "id": "8",
        "title": "设计地图节点系统 (AdventureMap/MapNode)",
        "description": "实现分层节点图结构,支持节点类型与连线关系",
        "details": "创建 Game.Core/Domain/AdventureMap.cs:\n- MapNode:\n  - NodeId、NodeType(Combat/Event/Rest/Shop/Elite/Boss)、Layer\n  - Connections: List<NodeId>(可达下一层节点)\n  - Completed: bool(是否已完成)\n  - Parameters: Dictionary<string,object>(节点参数,如 EncounterId/EventId/ShopTableId)\n- AdventureMap:\n  - Nodes: List<MapNode>\n  - CurrentNodeId\n  - CompletedNodes: HashSet<NodeId>\n  - StartNodeId、BossNodeId\n- 方法:\n  - GetAvailableNodes(): 返回当前可达节点(下一层连线节点)\n  - MoveToNode(nodeId): 更新 CurrentNodeId\n  - CompleteNode(nodeId): 标记完成\n  - IsPathComplete(): Boss 节点完成则章节完成\n地图生成逻辑可先硬编码模板(8–12 普通节点 + Boss),预留随机生成接口。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- AdventureMapTests: 验证节点连线关系、可达性计算\n- MoveToNode 测试: 非法移动(不连线节点)拒绝\n- CompleteNode 测试: 标记完成后 GetAvailableNodes 返回下一层\n- IsPathComplete 测试: Boss 完成返回 true",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 MapNode 数据模型与基础属性",
            "description": "实现 MapNode 类,包含节点标识、类型、层级、连线关系和完成状态。定义 NodeType 枚举(Combat/Event/Rest/Shop/Elite/Boss)和 NodeId 值类型。",
            "dependencies": [],
            "details": "在 Game.Core/Domain/AdventureMap.cs 中创建 MapNode record 类型,包含属性:NodeId(string)、NodeType(枚举)、Layer(int)、Connections(List<string>)、Completed(bool)、Parameters(Dictionary<string,object>)。使用 record 保证不可变性。NodeId 应采用 'layer_index' 命名规范(如 '0_0' 表示第0层第0个节点)。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:验证 MapNode 创建、属性初始化、Parameters 字典读写、NodeType 枚举有效性。测试默认值设置(Completed=false)。"
          },
          {
            "id": "2",
            "title": "创建 AdventureMap 容器与节点管理方法",
            "description": "实现 AdventureMap 类,管理所有节点集合、当前位置、已完成节点集合。实现 GetAvailableNodes()、MoveToNode()、CompleteNode() 三个核心方法。",
            "dependencies": [
              "1"
            ],
            "details": "在同一文件中创建 AdventureMap 类,包含属性:Nodes(List<MapNode>)、CurrentNodeId(string)、CompletedNodes(HashSet<string>)、StartNodeId、BossNodeId。GetAvailableNodes() 返回当前节点 Connections 列表对应的下一层可达节点。MoveToNode(nodeId) 验证目标节点是否在 GetAvailableNodes() 返回列表中,合法则更新 CurrentNodeId,非法则抛出异常。CompleteNode(nodeId) 将节点标记为已完成,更新对应 MapNode.Completed=true 和 CompletedNodes 集合。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:验证初始状态(CurrentNodeId=StartNodeId)、GetAvailableNodes() 正确返回下一层节点、MoveToNode() 接受合法移动、非法移动抛出异常、CompleteNode() 正确标记完成状态。"
          },
          {
            "id": "3",
            "title": "实现路径完成判定与地图生成模板",
            "description": "实现 IsPathComplete() 方法检查 Boss 节点完成状态。创建硬编码地图模板生成器,生成 8-12 个普通节点 + 1 个 Boss 节点的标准冒险地图。",
            "dependencies": [
              "2"
            ],
            "details": "IsPathComplete() 方法查询 Nodes 集合中 NodeType=Boss 的节点,检查其 NodeId 是否在 CompletedNodes 中。若 Boss 已完成则返回 true,否则返回 false。创建静态工厂方法 AdventureMap.CreateDefaultTemplate() 生成标准地图:第0层1个 Start 节点,第1-3层各 3-4 个混合类型节点(Combat/Event/Rest/Shop),第4层 1 个 Elite,第5层 1 个 Boss。所有节点连线采用分层递进逻辑(当前层节点连接到下一层所有或部分节点)。暂不实现随机生成,仅硬编码模板。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:验证 IsPathComplete() 在 Boss 未完成时返回 false,完成后返回 true。验证默认模板生成的节点总数(12-14个)、层级正确性(0-5层)、Boss 节点位置、连线关系完整性。"
          },
          {
            "id": "4",
            "title": "编写完整的单元测试套件(覆盖率 ≥90%)",
            "description": "为 MapNode 和 AdventureMap 编写全面的 xUnit 测试套件,覆盖所有方法、边界情况、异常路径。验证测试覆盖率达到 lines≥90%、branches≥85%。",
            "dependencies": [
              "3"
            ],
            "details": "创建 Tests/Core/Domain/AdventureMapTests.cs,包含以下测试类和用例:(1)MapNodeTests:节点创建、属性初始化、Parameters 修改、Completed 状态变化。(2)AdventureMapTests:初始化、GetAvailableNodes() 返回值正确性、MoveToNode() 合法/非法移动、CompleteNode() 状态更新、IsPathComplete() 逻辑。(3)集成测试:从 Start 节点逐步移动至 Boss 节点,完成全路径,验证 IsPathComplete() 返回 true。(4)边界测试:空节点集、重复完成节点、非存在节点移动。使用 FluentAssertions 进行断言,运行 dotnet test --collect:\"XPlat Code Coverage\" 验证覆盖率指标。",
            "status": "pending",
            "testStrategy": "xUnit 覆盖率门禁:使用 coverlet 收集代码覆盖率报告,确保 Game.Core/Domain/AdventureMap.cs 达到 lines≥90%、branches≥85%。所有测试必须通过,无跳过或条件执行。"
          },
          {
            "id": "5",
            "title": "验收与文档:提交代码审查与测试报告",
            "description": "确保实现完整可运行,生成测试覆盖率报告,编写简明文档说明 MapNode/AdventureMap 设计,提交代码审查。",
            "dependencies": [
              "4"
            ],
            "details": "验证所有测试通过(dotnet test 返回退出码 0),覆盖率报告输出至 logs/unit/AdventureMap-coverage.json。编写简明的实现注释或 API 文档(可选),说明 GetAvailableNodes()、MoveToNode()、IsPathComplete() 的逻辑与边界条件。确保代码风格符合项目约定(C# 命名规范、缩进、无魔法数字)。使用 git 提交变更,commit message 格式:'feat(adventure-map): implement MapNode and AdventureMap domain model (task 8)'。准备代码审查材料(diff、测试通过截图、覆盖率报告链接)。",
            "status": "pending",
            "testStrategy": "验收测试:本地运行 dotnet test 确保所有用例通过,运行覆盖率脚本验证指标达标。代码审查:由项目维护者检查逻辑正确性、异常处理、性能(O(n)复杂度查询)。集成验证:task 21(MapScreen UI) 依赖本任务,完成后可对接 UI 实现。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 设计地图节点系统 (AdventureMap/MapNode).",
        "updatedAt": null
      },
      {
        "id": "9",
        "title": "实现队伍管理 (Party)",
        "description": "创建队伍容器,维护英雄列表与共享资源(金币/标记)",
        "details": "创建 Game.Core/Domain/Party.cs:\n- Heroes: List<Hero>(T2 建议 2 名英雄)\n- Gold: int(共享金币)\n- Flags: Dictionary<string, object>(事件标记,用于事件链)\n- 方法:\n  - AddHero(hero): 添加英雄\n  - GetHero(heroId): 获取英雄\n  - GainGold(amount)/SpendGold(amount): 金币操作\n  - SetFlag(key, value)/GetFlag(key): 事件标记操作\n  - IsPartyAlive(): 检查是否全灭(所有英雄 HP ≤ 0)\n- 预留装备栏、天赋树字段(T2 不实现但保留 EquipmentSlots/TalentTree 占位)。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- PartyTests: 验证英雄添加/获取、金币操作、标记读写\n- IsPartyAlive 测试: 全灭判定、部分存活判定\n- 边界测试: 金币不足 SpendGold 抛异常或返回失败",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 Party 类与核心字段定义",
            "description": "在 Game.Core/Domain/ 创建 Party.cs 文件,定义队伍容器类,包含英雄列表、共享金币、事件标记等核心字段",
            "dependencies": [],
            "details": "创建 public class Party 包含:\n- Heroes: List<Hero> 英雄容器(支持 2 名英雄)\n- Gold: int 共享金币池\n- Flags: Dictionary<string, object> 事件链标记\n- EquipmentSlots: object 占位符(T2 不实现)\n- TalentTree: object 占位符(T2 不实现)\n添加属性访问器与初始化构造函数。验证 Heroes 列表初始化、Gold 默认值为 0、Flags 为空字典。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试验证类实例化、字段默认值、Heroes 列表初始状态"
          },
          {
            "id": "2",
            "title": "实现英雄容器操作方法",
            "description": "实现 AddHero、GetHero 方法,支持英雄添加与检索,附加重复验证与异常处理",
            "dependencies": [
              "1"
            ],
            "details": "实现 public void AddHero(Hero hero) 与 public Hero GetHero(string heroId):\n- AddHero: 验证 hero 非空,检查 Heroes 列表未超过 2 人上限,若超出抛 InvalidOperationException,支持同一英雄重复添加\n- GetHero: 按 heroId 查询 Heroes 列表,未找到抛 KeyNotFoundException\n异常消息应明确指示失败原因(英雄满队/英雄不存在)。",
            "status": "pending",
            "testStrategy": "xUnit 测试:\n- AddHero_ValidHero_Success: 正常添加英雄\n- AddHero_NullHero_ThrowsException: 空英雄异常\n- AddHero_ExceedsLimit_ThrowsException: 超过 2 人上限异常\n- GetHero_ExistingId_ReturnsHero: 获取存在英雄\n- GetHero_NonExistingId_ThrowsException: 获取不存在英雄异常"
          },
          {
            "id": "3",
            "title": "实现金币管理操作",
            "description": "实现 GainGold 与 SpendGold 方法,支持金币增减、不足异常、边界检查",
            "dependencies": [
              "1"
            ],
            "details": "实现 public void GainGold(int amount) 与 public void SpendGold(int amount):\n- GainGold: 金币增加,验证 amount > 0,否则抛 ArgumentException\n- SpendGold: 金币扣除,验证 amount > 0,检查 Gold >= amount,不足时抛 InvalidOperationException(消息:\"金币不足\")\n- 两方法都应更新内部 Gold 字段,支持金币归零但不负数场景(通过异常防守)。",
            "status": "pending",
            "testStrategy": "xUnit 测试:\n- GainGold_PositiveAmount_UpdatesGold: 正常增加金币\n- GainGold_ZeroOrNegative_ThrowsException: 非正数异常\n- SpendGold_SufficientBalance_UpdatesGold: 足额扣除\n- SpendGold_InsufficientBalance_ThrowsException: 不足异常\n- GainGold_SpendGold_Sequence: 混合操作序列验证金币正确"
          },
          {
            "id": "4",
            "title": "实现事件标记 (Flag) 操作与全灭判定",
            "description": "实现 SetFlag、GetFlag 方法与 IsPartyAlive 全灭检查逻辑",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "实现 public void SetFlag(string key, object value)、public object GetFlag(string key) 与 public bool IsPartyAlive():\n- SetFlag: 将 key-value 存入 Flags 字典,支持覆盖更新\n- GetFlag: 按 key 查询 Flags,未找到抛 KeyNotFoundException\n- IsPartyAlive: 遍历 Heroes 列表,检查所有英雄 HP <= 0,若全灭返回 false,否则返回 true(需英雄列表非空才检查,空列表视为已灭)\n标记操作用于事件链追踪与条件判定,应支持任意对象值。",
            "status": "pending",
            "testStrategy": "xUnit 测试:\n- SetFlag_NewKey_StoresValue: 新标记存储\n- SetFlag_ExistingKey_OverwritesValue: 标记覆盖\n- GetFlag_ExistingKey_ReturnsValue: 标记查询成功\n- GetFlag_NonExistingKey_ThrowsException: 标记不存在异常\n- IsPartyAlive_AllHeroesAlive_ReturnsTrue: 全体活着返回 true\n- IsPartyAlive_AllHeroesDead_ReturnsFalse: 全灭返回 false\n- IsPartyAlive_PartiallyAlive_ReturnsTrue: 部分存活返回 true\n- IsPartyAlive_EmptyHeroes_ReturnsFalse: 空英雄列表视为灭亡"
          },
          {
            "id": "5",
            "title": "编写 PartyTests 集成测试与覆盖率验证",
            "description": "创建 PartyTests.cs 完整单元测试套件,验证 CRUD 操作、边界条件、异常处理,达成覆盖率门禁(lines ≥90%, branches ≥85%)",
            "dependencies": [
              "2",
              "3",
              "4"
            ],
            "details": "在 Game.Core.Tests/Domain/ 创建 PartyTests.cs:\n- 聚合前 4 个子任务的所有单元测试用例\n- 验证英雄添加/获取、金币增减、标记读写、全灭判定的所有分支\n- 使用 FluentAssertions 编写可读断言\n- 运行 dotnet test --collect:\"XPlat Code Coverage\" 收集覆盖率报告\n- 确保 Party.cs 代码行覆盖率 ≥90%、分支覆盖率 ≥85%\n- 测试应验证所有异常路径、边界值(0 金币、2 人满队、空英雄列表等)。",
            "status": "pending",
            "testStrategy": "xUnit 完整覆盖:\n- 汇总前 4 个子任务所有测试用例\n- 补充集成测试: 多步骤操作序列(如增金币→花金币→检查结果)\n- 覆盖率门禁: 运行 dotnet test --collect:\"XPlat Code Coverage\",目标 Party.cs ≥90% lines, ≥85% branches\n- 所有测试用例命名规范: MethodName_Condition_ExpectedResult"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现队伍管理 (Party).",
        "updatedAt": null
      },
      {
        "id": "10",
        "title": "创建随机数服务 (RngService)",
        "description": "统一管理随机源,支持 Seed 固定以保证可复现",
        "details": "创建 Game.Core/Services/RngService.cs:\n- 字段: System.Random _rng\n- 方法:\n  - SetSeed(seed): 固定种子(用于调试/回放/测试)\n  - NextInt(min, max): 返回 [min, max) 随机整数\n  - NextFloat(): 返回 [0, 1) 随机浮点数\n  - Shuffle<T>(List<T>): Fisher-Yates 洗牌算法\n  - PickRandom<T>(List<T>): 随机选择一个元素\n- 设计为接口 IRngService,便于测试时 Mock。\n- 在 GameState 中记录 RunSeed,启动时调用 SetSeed(RunSeed)。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- RngServiceTests: 固定 Seed 验证可复现性(多次调用返回相同序列)\n- Shuffle 测试: 固定 Seed 洗牌结果一致\n- 边界测试: min >= max 抛异常、空列表 PickRandom 抛异常",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 IRngService 接口定义",
            "description": "在 Game.Core/Contracts 中定义 IRngService 接口,明确所有方法签名和契约",
            "dependencies": [],
            "details": "定义接口包含 SetSeed(int seed)、NextInt(int min, int max)、NextFloat()、Shuffle<T>(List<T>)、PickRandom<T>(List<T>) 五个方法。使用 XML 注释说明参数范围([min, max)、[0, 1))和异常条件(min >= max、空列表)。确保接口名称、参数命名规范,便于后续 Mock 和适配器注入。",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": "2",
            "title": "实现 RngService 核心类及 SetSeed/NextInt/NextFloat",
            "description": "在 Game.Core/Services/RngService.cs 中实现 IRngService,完成基础随机数生成方法",
            "dependencies": [
              "1"
            ],
            "details": "创建 RngService 类,包含 System.Random _rng 私有字段。实现 SetSeed(int seed) 重新初始化 _rng。实现 NextInt(int min, int max) 返回 [min, max) 整数,边界检查 min < max。实现 NextFloat() 返回 [0, 1) 浮点数。所有方法使用标准库 Random 的 Next()、NextDouble() 调用,无需自定义算法。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:验证 SetSeed 后 NextInt/NextFloat 返回序列可复现性(多次 SetSeed 相同值应返回相同序列);边界测试(min >= max 抛 ArgumentException)"
          },
          {
            "id": "3",
            "title": "实现 RngService 的 Shuffle<T> 方法(Fisher-Yates)",
            "description": "在 RngService 中实现通用洗牌方法,使用经典 Fisher-Yates 算法",
            "dependencies": [
              "2"
            ],
            "details": "实现 Shuffle<T>(List<T> list) 方法,采用标准 Fisher-Yates 算法:从列表末尾向前遍历,每次从 [0, i] 范围内随机选择一个位置进行交换。使用 NextInt(0, i+1) 生成随机索引。修改入参列表的元素顺序(in-place)。边界处理:空列表无操作,单元素列表无操作。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:固定 Seed 下多次洗牌结果一致;验证洗牌不改变元素个数和内容;空列表和单元素列表不抛异常"
          },
          {
            "id": "4",
            "title": "实现 RngService 的 PickRandom<T> 方法",
            "description": "在 RngService 中实现随机元素选择方法",
            "dependencies": [
              "2"
            ],
            "details": "实现 PickRandom<T>(List<T> list) 方法,返回列表中随机一个元素。使用 NextInt(0, list.Count) 生成随机索引。边界处理:空列表抛 ArgumentException(提示消息:'列表为空,无法选择')。确保多次调用固定 Seed 下返回相同元素序列。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:固定 Seed 下多次 PickRandom 返回相同元素;空列表抛 ArgumentException;验证返回元素在列表中存在"
          },
          {
            "id": "5",
            "title": "编写 RngService 完整单元测试(可复现性与边界)",
            "description": "为 RngService 创建全面的 xUnit 测试套件,重点验证 Seed 可复现性和所有方法的正确性",
            "dependencies": [
              "2",
              "3",
              "4"
            ],
            "details": "创建 Game.Core.Tests/Services/RngServiceTests.cs。测试用例包括:(1)固定 Seed 的可复现性:SetSeed(42) 后 NextInt/NextFloat 调用 10 次,记录结果;再次 SetSeed(42) 应得到相同序列。(2)Shuffle 一致性:固定 Seed 洗牌 List<int> {1,2,3,4,5} 两次应结果相同。(3)PickRandom 一致性:固定 Seed 从 List<string> 中选择 5 次应返回相同序列。(4)边界测试:min >= max 抛异常、空列表 PickRandom 抛异常、单元素洗牌无报错。使用 FluentAssertions 断言。覆盖率目标:lines ≥90%, branches ≥85%。",
            "status": "pending",
            "testStrategy": "xUnit + FluentAssertions;使用 Theory 或多个 Fact 测试多个 Seed 值;不依赖外部资源,所有测试确定性通过"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 4,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 创建随机数服务 (RngService).",
        "updatedAt": null
      },
      {
        "id": "11",
        "title": "实现游戏状态管理 (GameState)",
        "description": "创建一局冒险的存档快照结构,支持序列化与版本迁移",
        "details": "创建 Game.Core/State/RunGameState.cs:\n- 最小字段集合:\n  - Version: int(存档版本号,用于迁移)\n  - RunSeed: int(本局随机种子)\n  - CurrentAct: int(当前章节,T2 可固定为 1)\n  - Map: AdventureMap(地图进度)\n  - Party: Party(队伍状态)\n  - CompletedNodes: HashSet<NodeId>\n  - Statistics: RunStatistics(可选:击杀数、获得卡牌数等)\n- 方法:\n  - ToJson(): 序列化为 JSON\n  - FromJson(json): 反序列化并版本校验\n  - Validate(): 校验数据完整性(如英雄 HP > 0)\n利用现有 State/SaveData.cs 结构扩展或新建 RunGameState。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- RunGameStateTests: 验证序列化/反序列化一致性\n- 版本迁移测试: 老版本数据加载后补充默认值\n- Validate 测试: 非法数据(如负 HP)抛异常",
        "priority": "medium",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 RunGameState 数据类与字段定义",
            "description": "在 Game.Core/State/ 目录下创建 RunGameState.cs 文件,定义所有必要的字段(Version、RunSeed、CurrentAct、Map、Party、CompletedNodes、Statistics)并使用 record 类型确保不可变性。",
            "dependencies": [],
            "details": "创建 Game.Core/State/RunGameState.cs,包含字段:\n- Version: int (存档版本号)\n- RunSeed: int (本局随机种子)\n- CurrentAct: int (当前章节)\n- Map: AdventureMap (地图进度)\n- Party: Party (队伍状态)\n- CompletedNodes: HashSet<NodeId> (已完成节点)\n- Statistics: RunStatistics (游戏统计数据)\n使用 record 类型保证数据不可变性。所有字段添加 XML 注释说明用途。参考现有 State/SaveData.cs 结构进行扩展。",
            "status": "pending",
            "testStrategy": null
          },
          {
            "id": "2",
            "title": "实现 RunGameState 序列化与反序列化方法",
            "description": "在 RunGameState 类中实现 ToJson() 和 FromJson(json) 方法,使用 .NET 标准库进行 JSON 序列化操作。",
            "dependencies": [
              "1"
            ],
            "details": "在 RunGameState.cs 中添加:\n- public string ToJson(): 使用 System.Text.Json 将对象序列化为 JSON 字符串\n- public static RunGameState FromJson(string json): 反序列化 JSON 字符串为 RunGameState 对象\n- 反序列化时执行版本校验,确保 Version 字段与当前版本一致\n若版本不匹配,抛出 InvalidOperationException 异常并提示版本号不兼容\n确保序列化输出的 JSON 能完整还原所有字段状态。",
            "status": "pending",
            "testStrategy": "单元测试验证序列化一致性:序列化后再反序列化,确保所有字段值相等"
          },
          {
            "id": "3",
            "title": "实现 RunGameState Validate() 数据验证方法",
            "description": "在 RunGameState 类中添加 Validate() 方法,检查存档数据完整性与合法性,对非法数据抛出异常。",
            "dependencies": [
              "1"
            ],
            "details": "在 RunGameState.cs 中实现 Validate() 方法,验证规则:\n- Version 字段必须大于 0\n- RunSeed 必须非负\n- CurrentAct 必须在有效范围内(1 到最大章节数)\n- Party 对象不能为 null,且每个英雄 HP 必须 > 0\n- Map 对象不能为 null 且数据合法\n- CompletedNodes 不能为 null(可为空集合)\n若任何验证失败,抛出 ArgumentException 异常并说明失败原因。\nValidate() 应在 FromJson() 反序列化后自动调用一次。",
            "status": "pending",
            "testStrategy": "单元测试验证各项校验:测试非法 HP(负数、0)、无效章节号、null 党派等异常情况"
          },
          {
            "id": "4",
            "title": "编写 RunGameState 单元测试套件",
            "description": "在 Game.Core.Tests/ 中创建 RunGameStateTests.cs,编写完整的 xUnit 单元测试覆盖序列化、版本迁移、数据验证等场景。",
            "dependencies": [
              "2",
              "3"
            ],
            "details": "创建 Tests/Unit/State/RunGameStateTests.cs,包含测试用例:\n- TestSerializationRoundTrip: 验证对象 → JSON → 对象的往返一致性\n- TestVersionValidation: 测试版本号不匹配时的异常处理\n- TestValidateWithInvalidHP: 验证负 HP 或 0 HP 时抛异常\n- TestValidateWithNullParty: 验证 null 队伍时抛异常\n- TestValidateWithInvalidAct: 验证无效章节号时抛异常\n- TestEmptyCompletedNodes: 验证空 CompletedNodes 合法\n使用 FluentAssertions 进行断言,覆盖率达到 lines ≥90%、branches ≥85%。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试与代码覆盖率分析,使用 coverlet 收集覆盖率数据,确保关键代码路径被测试覆盖"
          },
          {
            "id": "5",
            "title": "集成 RunGameState 到现有架构并验收",
            "description": "将 RunGameState 集成到 Game.Core 项目中,检查与现有 SaveData.cs、AdventureMap、Party 等类型的兼容性,完成代码审查与验收。",
            "dependencies": [
              "4"
            ],
            "details": "完成集成验收:\n1. 检查 RunGameState 与现有 SaveData.cs 的关系(是否扩展或独立使用)\n2. 验证 AdventureMap、Party、NodeId、RunStatistics 等类型引用的正确性\n3. 确保 Game.Core.csproj 编译无警告、无错误\n4. 运行完整测试套件 dotnet test,确保所有测试通过\n5. 检查代码风格与注释符合项目规范\n6. 准备 CHANGELOG 条目记录此功能实现\n7. 确认不存在循环依赖或类型冲突",
            "status": "pending",
            "testStrategy": "集成测试与代码审查:运行完整单元测试,检查编译无警告,验证与相关类型的集成无误"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现游戏状态管理 (GameState).",
        "updatedAt": null
      },
      {
        "id": "12",
        "title": "实现奖励生成服务 (RewardManager)",
        "description": "战斗胜利后生成卡牌/金币奖励,支持职业过滤与稀有度权重",
        "details": "创建 Game.Core/Services/RewardManager.cs:\n- 方法:\n  - GenerateCardRewards(heroClassId, count=3): 从卡池中根据职业标签与稀有度权重随机抽取 count 张候选卡\n  - GenerateGoldReward(nodeType): 根据节点类型(普通/精英)返回金币数量(可配置范围)\n- 卡池过滤:\n  - 按职业标签过滤(若卡牌有 ClassTags)\n  - 按稀有度权重随机(Common 70%、Uncommon 25%、Rare 5%)\n- 使用 RngService.PickRandom 与 Shuffle 保证随机可复现。\n- 奖励配置可先硬编码,后续抽取到配置文件(JSON/Resource)。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- RewardManagerTests: 固定 Seed 验证奖励候选一致性\n- 职业过滤测试: 战士职业不出现法师卡\n- 稀有度权重测试: 大量样本验证权重分布(可选统计测试)\n- Mock RngService 保证测试可预测",
        "priority": "medium",
        "dependencies": [
          "1",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 RewardManager 类与卡池数据结构",
            "description": "在 Game.Core/Services 中创建 RewardManager.cs,定义卡池数据结构(CardPool)与稀有度权重常量,准备 GenerateCardRewards 与 GenerateGoldReward 方法的骨架。",
            "dependencies": [],
            "details": "1. 创建 Game.Core/Services/RewardManager.cs\n2. 定义稀有度权重常量(Common 70%, Uncommon 25%, Rare 5%)\n3. 定义 CardPool 数据结构(包含卡牌定义列表)\n4. 声明 GenerateCardRewards(heroClassId, count) 与 GenerateGoldReward(nodeType) 方法签名\n5. 注入 RngService 依赖用于随机操作\n6. 使用 record 与接口模式保证可测试性",
            "status": "pending",
            "testStrategy": "xUnit: 验证 RewardManager 构造、依赖注入、常量定义正确性"
          },
          {
            "id": "2",
            "title": "实现 GenerateCardRewards 职业过滤与稀有度权重逻辑",
            "description": "实现卡牌奖励生成方法,支持按职业标签(ClassTags)过滤卡牌,按稀有度权重随机抽取 count 张候选卡,使用 RngService.PickRandom 保证可复现性。",
            "dependencies": [
              "1"
            ],
            "details": "1. 实现职业过滤逻辑:根据 heroClassId 与卡牌 ClassTags 过滤合格卡牌\n2. 按稀有度分组:将过滤后卡牌按 Common/Uncommon/Rare 分类\n3. 按权重随机抽取:使用权重列表(Common 70%, Uncommon 25%, Rare 5%)调用 RngService.PickRandom\n4. 返回 count 张候选卡牌列表\n5. 处理边界:过滤后卡牌不足 count 时返回全部\n6. 单元测试用固定 Seed Mock RngService 验证候选一致性",
            "status": "pending",
            "testStrategy": "xUnit: 固定 Seed 验证职业过滤正确性、权重分布一致性、返回数量准确性"
          },
          {
            "id": "3",
            "title": "实现 GenerateGoldReward 金币范围与类型映射",
            "description": "实现金币奖励生成方法,根据节点类型(普通/精英)返回对应范围的金币数量,使用 RngService 生成随机值保证可复现。",
            "dependencies": [
              "1"
            ],
            "details": "1. 定义节点类型枚举:Normal/Elite(或扩展为更多类型)\n2. 定义金币范围配置:Normal (50-80), Elite (150-200)(硬编码,后续迁移到配置)\n3. 实现 GenerateGoldReward(nodeType) 方法:根据类型查询范围,使用 RngService.Next(min, max) 生成随机金币\n4. 验证 RngService 调用保证随机可复现\n5. 单元测试覆盖各类型金币生成范围",
            "status": "pending",
            "testStrategy": "xUnit: 固定 Seed 验证各节点类型金币范围正确、随机值在预期范围内"
          },
          {
            "id": "4",
            "title": "编写 RewardManager 完整单元测试与覆盖率验证",
            "description": "为 RewardManager 编写 xUnit 单元测试套件,覆盖职业过滤、稀有度权重、金币生成等核心逻辑,验证覆盖率 ≥90% lines 与 ≥85% branches。",
            "dependencies": [
              "2",
              "3"
            ],
            "details": "1. 创建 Game.Core.Tests/Services/RewardManagerTests.cs\n2. 编写测试类:\n   - RewardManager_GenerateCardRewards_FiltersByHeroClass: 验证职业过滤\n   - RewardManager_GenerateCardRewards_WithFixedSeed_ReturnsConsistentCandidates: 验证可复现性\n   - RewardManager_GenerateCardRewards_RarityDistribution_MatchesWeights: 统计测试验证权重(可选)\n   - RewardManager_GenerateGoldReward_Normal_ReturnsInRange: 验证普通节点金币范围\n   - RewardManager_GenerateGoldReward_Elite_ReturnsInRange: 验证精英节点金币范围\n3. Mock RngService 保证可预测\n4. 运行 dotnet test --collect:\"XPlat Code Coverage\" 验证覆盖率达标",
            "status": "pending",
            "testStrategy": "xUnit: 覆盖率 ≥90% lines, ≥85% branches; Mock RngService; 参数化测试多个职业与节点类型"
          },
          {
            "id": "5",
            "title": "集成 RewardManager 至事件系统与验证可玩",
            "description": "将 RewardManager 注册到 DI 容器,确保与 core.battle.ended 事件系统集成,编写冒烟测试验证战斗胜利后奖励生成工作流正常,为 Task 22 (RewardPanel) 做准备。",
            "dependencies": [
              "4"
            ],
            "details": "1. 在 DI 容器中注册 RewardManager(Game.Godot/Adapters/DependencyInjection.cs 或对应位置)\n2. 验证 RewardManager 可通过 DI 获取并调用\n3. 编写集成测试:模拟 core.battle.ended 事件触发,验证 RewardManager.GenerateCardRewards 与 GenerateGoldReward 被正确调用\n4. 可选:编写 GdUnit4 冒烟场景测试,验证战斗胜利 → 调用 RewardManager → 返回候选卡与金币的完整链路\n5. 记录输出奖励数据(候选卡 ID、金币数)用于 UI 展示(Task 22)\n6. 确保 Seed 可配置,便于重现特定奖励用于调试",
            "status": "pending",
            "testStrategy": "xUnit: DI 注册与调用正确; GdUnit4 (可选): 战斗胜利事件 → RewardManager 调用完整链路"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现奖励生成服务 (RewardManager).",
        "updatedAt": null
      },
      {
        "id": "13",
        "title": "实现事件系统 (EventManager)",
        "description": "事件节点展示与选项处理,复用 EffectResolver",
        "details": "创建 Game.Core/Domain/Event.cs 和 Game.Core/Services/EventManager.cs:\n- EventDefinition:\n  - EventId、TextKey(本地化文本)\n  - Options: List<EventOption>\n- EventOption:\n  - OptionTextKey、Requirements(可选:金币/标记条件)\n  - Effects: List<EffectCommand>(复用 EffectResolver)\n- EventManager 方法:\n  - GetEvent(eventId): 根据 ID 获取事件定义\n  - SelectOption(eventId, optionIndex, context): 执行选项 Effects,应用到 Party/BattleManager\n  - CheckRequirement(option, context): 校验选项可选性(金币不足置灰)\n- 事件抽取逻辑: 从事件池随机选择(RngService),T2 可先硬编码少量事件。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- EventManagerTests: 验证 SelectOption 执行效果(GainGold/Heal/AddCard)\n- 条件选项测试: 金币不足时 CheckRequirement 返回 false\n- TriggerBattle 测试: 事件触发战斗后进入 BattleManager\n使用 Mock EffectResolver 隔离依赖",
        "priority": "medium",
        "dependencies": [
          "3",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 EventDefinition 和 EventOption 领域模型",
            "description": "在 Game.Core/Domain/Event.cs 中定义事件的静态结构,包括事件ID、本地化文本Key、选项列表等核心属性",
            "dependencies": [],
            "details": "创建 EventDefinition record 类型,包含 EventId(string)、TextKey(string)、Options(List<EventOption>)。创建 EventOption record 类型,包含 OptionTextKey(string)、Requirements(RequirementCheck? - 金币/标记条件)、Effects(List<EffectCommand>)。使用 record 保证不可变性。添加 XML 注释说明各字段含义。遵循 Game.Core/Contracts/** 的命名规范。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试验证 EventDefinition 和 EventOption 创建、字段赋值正确性、record 类型的 Equals/GetHashCode 行为"
          },
          {
            "id": "2",
            "title": "实现 EventManager 核心方法 (GetEvent/CheckRequirement/SelectOption)",
            "description": "在 Game.Core/Services/EventManager.cs 中实现事件管理器,支持事件查询、条件检查和选项执行",
            "dependencies": [
              "1"
            ],
            "details": "创建 EventManager 类。实现 GetEvent(string eventId) 方法返回 EventDefinition,若未找到抛出异常。实现 CheckRequirement(EventOption option, BattleContext context) 方法验证金币/标记条件(金币不足或标记不存在返回 false)。实现 SelectOption(string eventId, int optionIndex, BattleContext context) 方法:获取事件和选项、检查条件、调用 EffectResolver 执行 Effects 列表、返回执行结果。使用依赖注入接收 EffectResolver 和其他服务。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:使用 NSubstitute Mock EffectResolver;测试 GetEvent 找到/未找到的情况;测试 CheckRequirement 金币充足/不足、标记存在/不存在的四种组合;测试 SelectOption 条件通过/不通过、Effects 执行顺序正确"
          },
          {
            "id": "3",
            "title": "实现事件池初始化与随机抽取逻辑",
            "description": "在 EventManager 中集成 RngService,实现硬编码事件池的初始化和随机事件抽取机制",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "在 EventManager 中创建私有事件池(Dictionary<string, EventDefinition>)。在构造函数中硬编码初始化至少 5 个基础事件(占位示例:宝箱、商人、强盗、祝福、诅咒)。实现 GetRandomEvent() 方法调用 RngService.Next(pool.Count) 随机选择一个事件并返回。确保 RngService 的可测试性(通过构造函数注入)。T2 阶段暂不实现动态事件加载。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:使用 NSubstitute Mock RngService;测试 GetRandomEvent 返回值属于事件池;多次调用验证随机性(通过 Mock 控制返回值);测试空事件池的异常处理"
          },
          {
            "id": "4",
            "title": "编写 EventManager 单元测试套件",
            "description": "为 EventManager 编写完整的单元测试,覆盖选项执行、条件校验、战斗触发等核心场景",
            "dependencies": [
              "2"
            ],
            "details": "创建 EventManagerTests.cs 文件。编写测试类覆盖:(1)SelectOption 执行 GainGold/Heal/AddCard 等 EffectCommand 的正确性(Mock EffectResolver 验证调用);(2)CheckRequirement 金币不足时返回 false、选项置灰的逻辑;(3)TriggerBattle 事件触发战斗后进入 BattleManager 的流程(Mock BattleManager.StartBattle 验证调用);(4)GetEvent 异常处理。使用 FluentAssertions 断言、NSubstitute Mock 隔离依赖。覆盖率目标 lines ≥90%, branches ≥85%。",
            "status": "pending",
            "testStrategy": "xUnit + FluentAssertions + NSubstitute。使用 Arrange-Act-Assert 模式。Mock EffectResolver、BattleManager、RngService。验证方法调用次数、参数、返回值。使用 coverlet 收集覆盖率报告。"
          },
          {
            "id": "5",
            "title": "集成 EventManager 与 EffectResolver,完成端到端测试",
            "description": "验证 EventManager 与 EffectResolver 的交互,确保选项效果在战斗上下文中正确应用",
            "dependencies": [
              "2",
              "4"
            ],
            "details": "创建集成测试类 EventManagerIntegrationTests.cs。编写场景测试:(1)创建包含多个 EffectCommand 的事件选项,调用 SelectOption,验证所有 Effects 被依次执行且状态正确更新(如金币增加、生命值变化、卡牌添加);(2)验证条件选项的金币校验与执行流程;(3)验证 TriggerBattle 选项正确初始化敌人并启动战斗。使用真实的 EffectResolver 实例(不 Mock),隔离与 BattleManager/PartyManager 的交互。检查选项执行后的 Party 状态(金币、生命、手牌)是否符合预期。",
            "status": "pending",
            "testStrategy": "集成测试,使用真实 EffectResolver 和 Mock BattleManager。验证 SelectOption 执行后 Party/Player 的状态变化。使用快照或数据比较方式断言最终状态正确。文档记录测试场景与预期结果对应关系。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现事件系统 (EventManager).",
        "updatedAt": null
      },
      {
        "id": "14",
        "title": "实现休息节点逻辑 (RestNode)",
        "description": "休息节点提供回血/升级卡二选一功能",
        "details": "创建 Game.Core/Services/RestService.cs:\n- 方法:\n  - HealParty(party, amount): 为所有英雄回复生命(固定值或百分比)\n  - UpgradeCard(hero, cardId): 将卡牌 ID 替换为升级版 ID(CardDefinition 中预定义 UpgradedId)\n- 二选一逻辑在 UI 层处理,Core 层只提供两个独立用例。\n- 回血量配置: 可先硬编码(如 30% MaxHP),后续抽取配置。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- RestServiceTests: 验证 HealParty 正确回复多英雄 HP,不超过上限\n- UpgradeCard 测试: 牌组中卡牌 ID 正确替换,升级后卡牌可用\n- 边界测试: 升级不存在卡牌抛异常",
        "priority": "low",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "实现 RestService.HealParty 方法",
            "description": "创建 Game.Core/Services/RestService.cs 中的 HealParty 方法，支持为所有英雄回复生命值，遵循生命值上限限制",
            "dependencies": [],
            "details": "实现 HealParty(party: Party, amount: int) 方法：遍历所有英雄，计算回复后生命值不超过 MaxHP；支持固定值或百分比回复（先硬编码30% MaxHP）；返回实际回复的总生命值。确保边界情况处理正确（英雄已满血、回复量为0等）。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：验证单英雄回血不超上限、多英雄回血分别计算、已满血英雄不回血、零回复处理"
          },
          {
            "id": "2",
            "title": "实现 RestService.UpgradeCard 方法",
            "description": "创建 RestService 中的 UpgradeCard 方法，将指定英雄牌组中的卡牌替换为升级版本",
            "dependencies": [
              "1"
            ],
            "details": "实现 UpgradeCard(hero: Hero, cardId: string) 方法：调用 hero.CardPile.UpgradeCard(cardId) 完成卡牌替换；需验证卡牌在 CardDefinition 中存在升级版 ID；升级失败时抛出 ArgumentException 并明确错误信息（卡牌不存在、无升级版本等）。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：验证升级成功替换卡牌ID、升级不存在卡牌抛异常、无升级版本抛异常、多英雄独立升级"
          },
          {
            "id": "3",
            "title": "编写 RestService 单元测试",
            "description": "为 HealParty 和 UpgradeCard 方法编写完整的 xUnit 单元测试套件，确保覆盖率达到标准",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "创建 Tests/Game.Core/Services/RestServiceTests.cs：包含 HealPartyTests（多英雄、上限限制、边界值）和 UpgradeCardTests（成功升级、异常处理）。使用 FluentAssertions 断言，NSubstitute Mock Party/Hero/CardPile 对象。验证行覆盖率 ≥90%，分支覆盖率 ≥85%。运行 dotnet test --collect:'XPlat Code Coverage' 收集覆盖率数据到 logs/unit/coverage.json。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试，目标覆盖率 lines ≥90%, branches ≥85%；使用 Mock 隔离依赖"
          },
          {
            "id": "4",
            "title": "验证与 CardPile 系统集成",
            "description": "确保 UpgradeCard 方法与现有 CardPile.UpgradeCard 方法集成正确，验证卡牌替换逻辑的端到端流程",
            "dependencies": [
              "2",
              "3"
            ],
            "details": "编写集成测试验证 RestService.UpgradeCard 调用 CardPile.UpgradeCard 的完整流程；检查升级前后卡牌在牌堆中的位置与状态；验证升级事件（如有）正确发布；确保升级卡牌可在后续抽牌时正确使用。测试用例涵盖单英雄单卡升级、多英雄并行升级、升级后立即抽牌等场景。",
            "status": "pending",
            "testStrategy": "xUnit 集成测试，使用实际 CardPile 对象而非 Mock；验证升级前后牌堆状态变化"
          },
          {
            "id": "5",
            "title": "提交代码并运行质量门禁检查",
            "description": "整合所有实现与测试，提交 PR 并验证覆盖率与质量门禁达标",
            "dependencies": [
              "3",
              "4"
            ],
            "details": "提交 RestService.cs 与所有测试文件；运行 dotnet test --collect:'XPlat Code Coverage' 验证覆盖率达标（lines ≥90%, branches ≥85%）；执行 py -3 scripts/python/quality_gates.py --unit 检查静态分析与代码质量；检查覆盖率报告 logs/unit/coverage.json；如有不合格项，修复并重新测试直到全绿；生成 PR 描述，引用 ADR-0005（质量门禁）与 Task 14。",
            "status": "pending",
            "testStrategy": "CI 质量门禁检查：覆盖率门禁 ≥90% lines ≥85% branches；SonarQube 或 Roslyn 分析器检查；无阻塞问题"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现休息节点逻辑 (RestNode).",
        "updatedAt": null
      },
      {
        "id": "15",
        "title": "实现商店节点逻辑 (ShopService)",
        "description": "商店支持购买卡牌与移除卡牌功能",
        "details": "创建 Game.Core/Services/ShopService.cs:\n- 方法:\n  - GenerateShopInventory(heroClassId, count=5): 随机生成商店售卖卡牌列表(职业过滤 + 稀有度)\n  - PurchaseCard(party, hero, cardId, price): 扣金币并将卡牌加入牌组\n  - RemoveCard(party, hero, cardId, price): 扣金币并移除卡牌(强力构筑工具)\n- 价格策略: 可先硬编码(如 Common 50金、Uncommon 75金、移除 75金),后续配置化。\n- 金币不足时返回失败或抛异常。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Shop-DTOs.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md; docs/architecture/overlays/PRD-rouge-manager/08/_index.md",
        "testStrategy": "xUnit 单元测试:\n- ShopServiceTests: 验证 GenerateShopInventory 随机性(固定 Seed)\n- PurchaseCard 测试: 金币足够时成功购买,金币不足时失败\n- RemoveCard 测试: 移除成功后牌组中不含该卡\n使用 Mock RngService 保证测试可预测",
        "priority": "low",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 ShopService 类和价格常数",
            "description": "在 Game.Core/Services/ 中创建 ShopService.cs 类框架,定义卡牌稀有度对应的价格常数(Common 50金、Uncommon 75金、移除 75金),建立构造函数并注入必要依赖(RngService、CardRepository)。",
            "dependencies": [],
            "details": "创建 ShopService 类,包含私有字段 _rngService 和 _cardRepository,定义公共常数 PRICE_COMMON=50、PRICE_UNCOMMON=75、PRICE_REMOVE=75,实现构造函数进行依赖注入。参考 RewardManager 的设计模式,保持一致性。",
            "status": "pending",
            "testStrategy": "单元测试验证常数正确性和构造函数依赖注入"
          },
          {
            "id": "2",
            "title": "实现 GenerateShopInventory 方法(职业过滤+稀有度随机)",
            "description": "实现 GenerateShopInventory(heroClassId, count=5) 方法,根据职业过滤可用卡牌池,按稀有度权重随机生成商店售卖列表。使用 RngService 确保可预测性。",
            "dependencies": [
              "1"
            ],
            "details": "从 CardRepository 获取按职业过滤的卡牌列表,按稀有度(Common/Uncommon/Rare)设定权重,调用 _rngService.SelectWithWeights() 随机选择 count 张卡牌,返回 List<CardDefinition>。权重建议 Common 60%、Uncommon 30%、Rare 10%。",
            "status": "pending",
            "testStrategy": "xUnit 测试:固定 Seed 验证随机性、职业过滤正确性、稀有度分布符合权重"
          },
          {
            "id": "3",
            "title": "实现 PurchaseCard 方法(扣金币+加牌)",
            "description": "实现 PurchaseCard(party, hero, cardId, price) 方法,验证党金币充足,扣除金币,将卡牌添加至英雄牌组。金币不足时返回结果对象或抛异常。",
            "dependencies": [
              "1"
            ],
            "details": "检查 party.Gold >= price,若否返回失败结果或抛 InsufficientGoldException,若成功则执行 party.Gold -= price 和 hero.Deck.AddCard(cardId),发布 CardPurchased 事件,返回成功结果。考虑使用 Result<T> 模式或异常,与项目现有错误处理风格保持一致。",
            "status": "pending",
            "testStrategy": "xUnit 测试:金币充足购买成功、金币不足失败、验证 Deck 状态更新、验证 Party.Gold 扣减"
          },
          {
            "id": "4",
            "title": "实现 RemoveCard 方法(扣金币+移牌)",
            "description": "实现 RemoveCard(party, hero, cardId, price) 方法,验证党金币充足,扣除移除费用,从英雄牌组中移除卡牌。金币不足时返回失败。",
            "dependencies": [
              "1"
            ],
            "details": "检查 party.Gold >= price,若否返回失败结果或抛异常,若成功则执行 party.Gold -= price 和 hero.Deck.RemoveCard(cardId),发布 CardRemoved 事件,返回成功结果。处理边界:卡牌不存在时返回失败而非异常。",
            "status": "pending",
            "testStrategy": "xUnit 测试:移除成功场景、金币不足失败、移除不存在卡牌失败、验证牌组移除正确"
          },
          {
            "id": "5",
            "title": "编写 ShopServiceTests 单元测试套件",
            "description": "创建 Game.Core.Tests/Services/ShopServiceTests.cs,使用 Mock RngService 编写全覆盖的单元测试,验证库存生成随机性、购买逻辑、移除逻辑的所有场景。",
            "dependencies": [
              "2",
              "3",
              "4"
            ],
            "details": "创建测试类,使用 Substitute.For<IRngService>() 构造 Mock,测试用例包括:(1) GenerateShopInventory 固定 Seed 可复现、(2) GenerateShopInventory 职业过滤正确、(3) PurchaseCard 成功购买、(4) PurchaseCard 金币不足失败、(5) RemoveCard 成功移除、(6) RemoveCard 金币不足失败、(7) RemoveCard 卡牌不存在失败。使用 FluentAssertions 断言,覆盖率目标 ≥90%。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试,Mock RngService,FluentAssertions 断言,覆盖率 ≥90%,使用固定 Seed 确保随机可预测"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现商店节点逻辑 (ShopService).",
        "updatedAt": null
      },
      {
        "id": "16",
        "title": "创建一局流程控制器 (RunManager)",
        "description": "管理一局冒险的生命周期:开局→选路→节点内容→结算→重开",
        "details": "创建 Game.Core/Services/RunManager.cs:\n- 方法:\n  - StartNewRun(seed): 生成 RunSeed、初始化 Party(2 英雄 + 初始牌组)、生成地图、定位起点\n  - EnterNode(nodeId): 根据节点类型进入对应内容(Combat/Event/Rest/Shop/Boss)\n  - CompleteNode(nodeId): 标记节点完成,返回地图\n  - EndRun(result): 章节完成或全灭时触发结算\n- 节点内容调度:\n  - Combat → 调用 BattleManager.StartBattle → 胜利触发奖励 → 回地图\n  - Event → 调用 EventManager.SelectOption → 回地图\n  - Rest/Shop → 调用对应 Service → 回地图\n  - Boss → 战斗 → 胜利触发章节结算 → 可重开\n- 发布事件: RunStarted/core.map.node.selected/NodeCompleted/RunEnded。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- RunManagerTests: 验证 StartNewRun 初始化正确(Party/Map/Seed)\n- EnterNode 测试: 不同节点类型调用正确 Service\n- CompleteNode 测试: 节点完成后 GetAvailableNodes 返回下一层\n- EndRun 测试: Boss 胜利触发 RunEnded(Victory),全灭触发 RunEnded(Defeat)\n使用 Mock BattleManager/EventManager 等依赖",
        "priority": "high",
        "dependencies": [
          "7",
          "8",
          "11",
          "12",
          "13",
          "14",
          "15"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "设计 RunManager 状态机架构",
            "description": "设计一局冒险的状态转移图，包括初始化→地图→进入节点→节点处理→节点完成→地图循环→结束的完整状态流转。定义状态枚举和转移条件。",
            "dependencies": [],
            "details": "创建 RunState 枚举（Initializing/OnMap/EnteringNode/InNode/NodeCompleted/RunEnded），绘制状态转移图，定义各状态的前置条件和后续行为。明确 Boss 战胜利触发章节结算的特殊流转。为后续实现奠定基础。",
            "status": "pending",
            "testStrategy": "单元测试验证状态转移合法性（如禁止从 RunEnded 回到 OnMap）；测试特殊路径如 Boss 胜利直接转 RunEnded"
          },
          {
            "id": "2",
            "title": "实现 RunManager 初始化和进度管理",
            "description": "实现 StartNewRun 方法生成 RunSeed、初始化 Party、生成地图、定位起点；实现 CompleteNode 方法标记节点完成并返回地图。",
            "dependencies": [
              "7",
              "8",
              "11",
              "12",
              "13"
            ],
            "details": "创建 Game.Core/Services/RunManager.cs，注入 MapGenerator/PartyInitializer/RngService/EventBus。StartNewRun 调用这些依赖生成初始游戏状态，发布 RunStarted 事件。CompleteNode 更新地图状态，调用 GetAvailableNodes 获取下一层节点，返回地图视图。使用依赖注入便于测试 Mock。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：验证 StartNewRun 后 Party 包含 2 英雄且初始牌组正确、地图生成、RunStarted 事件发布；验证 CompleteNode 后 GetAvailableNodes 返回正确下一层。使用 Mock 依赖。"
          },
          {
            "id": "3",
            "title": "实现节点内容调度和 EnterNode 方法",
            "description": "实现 EnterNode 方法根据节点类型调度到 BattleManager/EventManager/RestService/ShopManager；管理节点内容的执行和返回。",
            "dependencies": [
              "2",
              "11",
              "14",
              "15"
            ],
            "details": "在 RunManager 中实现 EnterNode(nodeId) 方法，检查节点类型并调用对应 Service（如 Combat → BattleManager.StartBattle，Event → EventManager.SelectOption）。发布 core.map.node.selected 事件。处理节点执行完成后的回调机制，确保执行完成后自动触发 CompleteNode。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：验证不同节点类型调用正确的 Service；验证 core.map.node.selected 事件发布；使用 Mock 各 Service 验证调用参数正确。测试边界情况如无效节点 ID。"
          },
          {
            "id": "4",
            "title": "实现 RunManager 胜负判定和完整流程集成测试",
            "description": "实现 EndRun 方法处理章节完成和全灭结算；编写 xUnit 集成测试验证完整一局流程（初始化→选路→战斗→奖励→商店→Boss→结算）。",
            "dependencies": [
              "1",
              "2",
              "3"
            ],
            "details": "实现 EndRun(result) 方法，根据 result（Victory/Defeat）发布相应 RunEnded 事件，触发奖励结算或失败处理。编写 RunManagerIntegrationTests，模拟完整一局流程：StartNewRun → 多次 EnterNode(Combat) → CompleteNode → 进入 Shop → 再次 Combat → Boss 胜利 → EndRun(Victory)。使用 Mock 依赖和虚假数据。",
            "status": "pending",
            "testStrategy": "xUnit 集成测试：验证完整一局流程各阶段的状态转移正确；验证 Boss 战胜利触发 RunEnded(Victory)、全灭触发 RunEnded(Defeat)；验证各关键事件（RunStarted/core.map.node.selected/NodeCompleted/RunEnded）的发布时机；覆盖多条路径如不进商店直接 Boss 等分支。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 8,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on 创建一局流程控制器 (RunManager).",
        "updatedAt": null
      },
      {
        "id": "17",
        "title": "配置卡牌静态数据 (JSON/Resource)",
        "description": "创建至少 20 张卡牌的静态配置,覆盖攻击/防御/技能类型",
        "details": "在 Game.Core/Data 或 Godot Resources 中创建卡牌配置:\n- 格式: JSON 数组或 Godot Resource(.tres)\n- 最小卡牌集合(每职业 5 张,2 职业共 10 张 + 通用 10 张):\n  - 战士: 打击(Damage 6)/防御(Block 5)/重击(Damage 12,消耗 2)/战吼(力量 +2)/狂怒(Damage 15,Exhaust)\n  - 法师: 火球(Damage 8)/冰甲(Block 4,抽 1)/闪电链(Damage 4 All)/法力涌流(能量 +2)/陨石(Damage 20,消耗 3)\n  - 通用: 闪避(Block 3)/药水(Heal 5)/虚弱术(易伤 2 层)/中毒术(中毒 3 层)/抽牌(Draw 2)\n- 每张卡包含:\n  - id、name、cost、cardType、targetRule、effects(List<EffectCommand 序列化)、textKey、rarity、classTags\n  - upgradedId(升级版 ID,如 \"card_001\" → \"card_001_plus\")\n- 升级版: 消耗 -1 或伤害 +3 或效果增强。\n\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "集成测试:\n- 加载配置文件验证反序列化成功\n- 每张卡 EffectCommands 可被 EffectResolver 执行\n- 升级 ID 映射正确\n手动验证: UI 中展示卡牌文本与效果一致",
        "priority": "medium",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建卡牌数据模型与序列化格式",
            "description": "定义卡牌配置的数据结构与序列化格式(JSON或Resource),建立战士/法师/通用卡牌的基础模型",
            "dependencies": [
              "1",
              "3"
            ],
            "details": "在 Game.Core/Data 中创建 CardDataModel.cs 定义卡牌配置字段(id、name、cost、cardType、targetRule、effects、textKey、rarity、classTags、upgradedId)。实现 CardDefinitionJsonLoader 支持从 JSON 反序列化。定义 EffectCommand 序列化格式。创建示例 cards.json 包含战士/法师/通用卡牌元数据。添加单元测试验证反序列化正确性。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:验证 JSON 反序列化成功、字段映射正确、EffectCommands 可被序列化与反序列化"
          },
          {
            "id": "2",
            "title": "编写战士与法师卡牌配置(10张)",
            "description": "根据设计创建两个职业的 5+5 张卡牌配置,包含攻击/防御/技能效果",
            "dependencies": [
              "1"
            ],
            "details": "在 .godot/res/data/cards/ 或 Game.Core/Data/cards.json 中编写战士卡牌(打击/防御/重击/战吼/狂怒)与法师卡牌(火球/冰甲/闪电链/法力涌流/陨石)。每张卡指定 cost、damage/block/heal 等 EffectCommands。为每张卡创建对应的升级版本(升级版消耗 -1 或伤害 +3)。验证所有卡牌 ID 唯一且格式一致。",
            "status": "pending",
            "testStrategy": "集成测试:加载配置验证反序列化、验证每张卡的 EffectCommands 完整性、验证升级 ID 映射正确"
          },
          {
            "id": "3",
            "title": "编写通用卡牌配置(10张)",
            "description": "创建中立卡牌配置,覆盖闪避/药水/虚弱术/中毒术/抽牌等通用效果",
            "dependencies": [
              "1"
            ],
            "details": "在 cards.json 或 Resource 文件中编写 10 张通用卡牌(闪避、药水、虚弱术、中毒术、抽牌、其他通用卡)。每张卡详细定义 cost、targetRule、effects 列表。为通用卡创建升级版本。确保所有卡牌 classTags 包含 'neutral' 标记,与职业卡区分。",
            "status": "pending",
            "testStrategy": "加载测试:验证所有通用卡反序列化、验证升级映射、验证 classTags 正确标记为 neutral"
          },
          {
            "id": "4",
            "title": "验证卡牌效果指令与 EffectResolver 兼容性",
            "description": "确保配置中的所有 EffectCommands 能被 EffectResolver 正确执行,包括伤害/治疗/状态效果",
            "dependencies": [
              "2",
              "3"
            ],
            "details": "编写集成测试,加载所有 20 张卡牌配置,逐张验证其 EffectCommands 列表。对每个 EffectCommand 调用 EffectResolver.Resolve() 验证执行不出错。覆盖 DamageEffect、BlockEffect、HealEffect、StatusEffect(虚弱/中毒)、DrawEffect 等。记录任何序列化错误或缺失的 Effect 处理器。",
            "status": "pending",
            "testStrategy": "xUnit 集成测试:EffectCompatibilityTests,验证每张卡的所有 Effects 能被 EffectResolver 正确解析与执行"
          },
          {
            "id": "5",
            "title": "生成卡牌配置文档与升级映射表",
            "description": "创建卡牌配置文档,列举所有 20 张卡牌的升级映射、效果描述、数值平衡验证",
            "dependencies": [
              "2",
              "3",
              "4"
            ],
            "details": "编写 docs/cards-config.md 或 Excel 表格,列出所有卡牌(战士/法师/通用)的 ID、名称、消耗、效果、升级版本。为每张卡牌生成升级映射表(如 card_warrior_001 → card_warrior_001_plus)。验证数值平衡(如伤害卡的期望伤害值合理、防御卡的防御值与消耗比例一致)。为 UI 与文档提供卡牌效果文本(利用 textKey 关联多语言翻译)。",
            "status": "pending",
            "testStrategy": "手动验证:检查升级映射表的完整性、检查数值平衡(如消耗与效果强度比例)"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 配置卡牌静态数据 (JSON/Resource).",
        "updatedAt": null
      },
      {
        "id": "18",
        "title": "配置敌人与遭遇静态数据",
        "description": "创建至少 10 个敌人定义与 5 个遭遇配置",
        "details": "在 Game.Core/Data 或 Godot Resources 中创建敌人/遭遇配置:\n- 敌人定义(EnemyDefinition):\n  - id、name、maxHealth、intentTable(技能序列)\n  - 最小敌人集合:\n    - 史莱姆(HP 30,攻击 6)\n    - 哥布林(HP 40,攻击 8/防御 5 交替)\n    - 强盗(HP 50,攻击 10,施加虚弱)\n    - 巫师(HP 35,远程攻击 12,施加中毒)\n    - 骑士(HP 60,攻击 7,格挡 10)\n    - 精英: 狂战士(HP 100,攻击 15,暴怒 +力量)\n    - 精英: 黑暗法师(HP 80,群体攻击 8,上易伤)\n    - Boss: 龙王(HP 200,多阶段技能,召唤小怪)\n- 遭遇配置(EncounterDefinition):\n  - id、enemyIds(敌群组合)、difficulty\n  - 普通遭遇: 2–3 只小怪(史莱姆 x2、哥布林 + 强盗)\n  - 精英遭遇: 1 只精英 + 1 只小怪\n  - Boss 遭遇: Boss 单体或 Boss + 护卫。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "集成测试:\n- 加载配置验证反序列化\n- IntentTable 可被 EnemyAI 正确解析与执行\n手动验证: 战斗中敌人意图展示正确",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "定义10个敌人及其IntentTable技能序列",
            "description": "在 Game.Core/Data 中创建 EnemyDefinition 类及10个具体敌人配置文件,包括普通敌人(史莱姆、哥布林、强盗、巫师、骑士)、精英敌人(狂战士、黑暗法师)、Boss(龙王),每个敌人需定义 ID、名称、最大血量、意图表(IntentTable)和特殊技能列表,意图表包含技能循环序列供 EnemyAI 解析执行。",
            "dependencies": [],
            "details": "1. 创建 Game.Core/Domain/Enemy.cs 定义 EnemyDefinition 记录类,包含字段:id(string)、name(string)、maxHealth(int)、attack(int)、defense(int)、rarity(Enum: Common/Elite/Boss)、intentTable(List<Intent>)、specialAbilities(List<Ability>)。\n2. 创建 Game.Core/Domain/Intent.cs 定义 Intent 记录类:actionType(Attack/Defend/Ability)、targetRule(SingleEnemy/AllEnemies/Random)、value(int)、abilityId(string)。\n3. 在 Game.Core/Data/EnemyDefinitions.cs 静态类中定义10个敌人:\n   - 史莱姆: HP30,攻击6,意图表[Attack,Attack,Defend]\n   - 哥布林: HP40,攻击8,防御5,意图表[Attack,Attack,Defend,Defend]\n   - 强盗: HP50,攻击10,特殊技能\"施加虚弱\"\n   - 巫师: HP35,攻击12,特殊技能\"施加中毒\"\n   - 骑士: HP60,攻击7,防御10,意图表[Defend,Attack,Defend]\n   - 狂战士: HP100,攻击15,特殊技能\"暴怒(增加力量)\"\n   - 黑暗法师: HP80,攻击8,特殊技能\"群体攻击\",\"施加易伤\"\n   - 龙王: HP200,多阶段技能,特殊技能\"召唤小怪\"\n   - 另需补充2个敌人至总数10个。\n4. 编写 xUnit 单元测试 Tests/Core/Domain/EnemyDefinitionTests.cs:验证敌人创建、字段有效性、意图表格式正确、特殊技能列表非空。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试验证:EnemyDefinition 字段完整性、IntentTable 格式正确性、rarity 枚举有效性。覆盖率目标 lines ≥90%, branches ≥85%。"
          },
          {
            "id": "2",
            "title": "定义5个遭遇配置与难度标签",
            "description": "在 Game.Core/Data 中创建 EncounterDefinition 类及5个具体遭遇配置,包括普通遭遇(2-3只小怪)、精英遭遇(1只精英+1只小怪)、Boss遭遇(Boss单体或Boss+护卫),每个遭遇需定义 ID、敌人ID组合、难度等级,并关联相应的敌人定义以供战斗系统加载。",
            "dependencies": [
              "1"
            ],
            "details": "1. 创建 Game.Core/Domain/Encounter.cs 定义 EncounterDefinition 记录类,包含字段:id(string)、name(string)、enemyIds(List<string>)、difficulty(Enum: Easy/Normal/Hard/Nightmare)、rewardMultiplier(float)。\n2. 在 Game.Core/Data/EncounterDefinitions.cs 静态类中定义5个遭遇:\n   - 普通遭遇1: 史莱姆×2,难度 Easy\n   - 普通遭遇2: 哥布林+强盗,难度 Normal\n   - 精英遭遇: 狂战士+史莱姆,难度 Hard\n   - 精英遭遇: 黑暗法师+骑士,难度 Hard\n   - Boss遭遇: 龙王,难度 Nightmare\n3. 编写集成测试 Tests/Core/Domain/EncounterDefinitionTests.cs:验证遭遇配置创建、敌人ID有效性、难度映射、奖励倍数计算。\n4. 编写集成测试 Tests/Integration/EncounterLoadingTests.cs:验证 EncounterDefinitions 可正确加载敌人定义、战斗系统可根据遭遇配置生成敌人实例。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试验证:EncounterDefinition 字段完整性、enemyIds 引用有效性、difficulty 枚举有效性。GdUnit4 集成测试验证:通过遭遇ID加载时,所有关联敌人定义成功解析,战斗场景中敌人阵容正确显示。覆盖率目标 lines ≥90%, branches ≥85%。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break down this task with a focus on 配置敌人与遭遇静态数据.",
        "updatedAt": null
      },
      {
        "id": "19",
        "title": "配置事件静态数据",
        "description": "创建至少 5 个事件定义,覆盖奖励/代价/战斗触发",
        "details": "在 Game.Core/Data 或 Godot Resources 中创建事件配置:\n- 最小事件集合:\n  - 神秘宝箱: 选项 A(获得 100 金)/选项 B(获得稀有卡,扣 20 HP)/选项 C(离开)\n  - 流浪商人: 选项 A(购买药水 50 金,回血 20)/选项 B(拒绝)\n  - 强盗伏击: 选项 A(战斗,胜利奖励金币)/选项 B(交 50 金离开)/选项 C(拒绝,强制战斗)\n  - 神殿祝福: 选项 A(升级一张卡)/选项 B(全体回血 30%)\n  - 诅咒祭坛: 选项 A(获得强力卡,扣最大 HP 10%)/选项 B(离开)\n- 每个事件包含:\n  - id、textKey、options(List<EventOption>)\n  - EventOption: optionTextKey、requirements(可选)、effects(List<EffectCommand>)\n- 条件选项: 如强盗伏击选项 B 需要金币 ≥ 50。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "集成测试:\n- 加载配置验证反序列化\n- 每个选项 Effects 可被 EffectResolver 执行\n- 条件选项正确过滤(金币不足时不可选)\n手动验证: UI 展示事件文本与选项一致",
        "priority": "low",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 EventDefinition 与 EventOption 数据契约",
            "description": "在 Game.Core/Contracts/Events 目录下定义事件配置的 C# 数据类型,包括事件定义、选项定义和效果指令结构。",
            "dependencies": [],
            "details": "创建以下数据契约类型:\n1. EventDefinition record: 包含 Id(string)、TextKey(string)、Options(List<EventOption>)\n2. EventOption record: 包含 OptionTextKey(string)、Requirements(EventRequirement?)、Effects(List<EffectCommand>)\n3. EventRequirement record: 包含需求类型(如 GoldRequired)与阈值\n4. EffectCommand record: 作为现有的 SSoT,引用路径而不复制\n5. 添加 XML 注释说明每个字段用途\n产出文件: Game.Core/Contracts/Events/EventDefinition.cs、EventOption.cs、EventRequirement.cs",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EventDefinitionTests: 验证对象创建、字段不为空、Types 不可变\n- EventOptionTests: 验证可选条件 Requirements、Effects 列表有效\n- 覆盖率目标 lines ≥90%, branches ≥85%"
          },
          {
            "id": "2",
            "title": "编写 5 个事件的静态配置数据",
            "description": "根据任务描述中的 5 个事件(神秘宝箱、流浪商人、强盗伏击、神殿祝福、诅咒祭坛)创建具体的 JSON 配置或 C# 常量定义。",
            "dependencies": [
              "1"
            ],
            "details": "创建 Game.Core/Data/EventDefinitions.cs 或 resources/events_config.json:\n1. 神秘宝箱: 3 个选项(+100金 / +稀有卡-20HP / 离开)\n2. 流浪商人: 2 个选项(购买药水50金回血20 / 拒绝)\n3. 强盗伏击: 3 个选项(战斗赢金币 / 交50金离开[需金币≥50] / 拒绝强制战斗)\n4. 神殿祝福: 2 个选项(升级一张卡 / 全体回血30%)\n5. 诅咒祭坛: 2 个选项(获得强力卡-10%MaxHP / 离开)\n每个事件包含 EventDefinition 对象,每个选项包含 Requirements(如金币≥50)与 EffectCommand 列表。\n产出文件: Game.Core/Data/EventDefinitions.cs(约 80-120 行代码+注释)",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EventConfigTests: 验证 5 个事件配置加载无异常\n- 验证每个选项的 Requirements 和 Effects 列表不为空或正确\n- 验证强盗伏击选项 B 的金币条件正确设置(GoldRequired=50)"
          },
          {
            "id": "3",
            "title": "实现事件配置加载与反序列化逻辑",
            "description": "创建 EventLoader 或 EventRepository 来加载、缓存和管理事件定义,支持通过 EventId 查询。",
            "dependencies": [
              "2"
            ],
            "details": "创建 Game.Core/Services/EventRepository.cs:\n1. 静态初始化方法 Initialize() 加载所有 EventDefinition(从 C# 常量或 JSON 资源)\n2. 方法 GetEventById(string eventId): EventDefinition - 返回事件定义\n3. 方法 GetAllEvents(): IEnumerable<EventDefinition> - 返回所有事件\n4. 验证反序列化异常处理与日志(如配置缺失事件)\n5. 考虑单例模式或注入方式与现有 ServiceLocator 一致\n产出文件: Game.Core/Services/EventRepository.cs(约 50-80 行)\n产出文件: Game.Godot/Autoload/EventManager.cs(Godot 适配层,约 30-50 行)",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EventRepositoryTests: 验证 Initialize() 后 GetEventById() 返回正确事件\n- 验证所有 5 个事件都可被查询到\n- 边界测试: 查询不存在的 eventId 抛出或返回 null\n- 验证反序列化异常时的错误处理"
          },
          {
            "id": "4",
            "title": "验证事件选项条件过滤与效果执行可行性",
            "description": "测试条件选项(如强盗伏击选项 B 需金币≥50)的过滤逻辑与效果指令的可执行性。",
            "dependencies": [
              "3"
            ],
            "details": "创建 Game.Core/Services/EventOptionFilterService.cs:\n1. 方法 FilterAvailableOptions(EventDefinition, GameState): List<EventOption> - 根据当前游戏状态过滤可用选项\n2. 方法 CanSelectOption(EventOption, GameState): bool - 验证单个选项是否满足条件\n3. 支持的条件: GoldRequired、MaxHPRequired 等\n4. 验证所有效果指令(如 +100金、-20HP)可被 EffectResolver 理解与执行(不需实现效果,仅验证兼容性)\n产出文件: Game.Core/Services/EventOptionFilterService.cs(约 40-60 行)\n集成验证: EffectResolver 可处理所有 5 个事件的效果指令列表",
            "status": "pending",
            "testStrategy": "xUnit 单元测试:\n- EventOptionFilterTests: 验证条件过滤逻辑\n  - 强盗伏击: 金币≥50 时选项 B 可用,<50 时不可用\n  - 其他选项无条件约束时始终可用\n- EffectCompatibilityTests: 验证所有事件的 EffectCommand 列表可被 EffectResolver 识别\n- 覆盖率目标 lines ≥90%"
          },
          {
            "id": "5",
            "title": "编写事件配置集成测试与手动验收清单",
            "description": "通过 GdUnit4 或手工清单验证事件配置加载、选项过滤与 UI 展示一致。",
            "dependencies": [
              "4"
            ],
            "details": "创建两部分:\n1. GdUnit4 集成测试 tests/e2e/test_event_config.gd(约 60-80 行):\n   - 测试加载 EventRepository 无异常\n   - 验证每个事件配置反序列化正确\n   - 模拟游戏状态,验证条件过滤(如强盗伏击选项可见性)\n   - 验证效果指令列表可被 EffectResolver 处理\n2. 手动验收清单 docs/testing/event-config-checklist.md:\n   - [ ] 加载 5 个事件配置成功\n   - [ ] 神秘宝箱显示 3 个选项\n   - [ ] 强盗伏击: 金币<50 时隐藏选项 B,≥50 时显示\n   - [ ] 每个选项点击后触发正确的效果(仅 UI 展示验证)\n产出文件: tests/e2e/test_event_config.gd、docs/testing/event-config-checklist.md",
            "status": "pending",
            "testStrategy": "GdUnit4 集成测试:\n- 完整配置加载与反序列化验证\n- 条件过滤逻辑验证(使用 Mock GameState)\n- 效果兼容性验证\n手动验收:\n- 执行清单,验证 UI 展示与配置一致\n通过标准: GdUnit4 测试全绿,手动清单各项通过"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 配置事件静态数据.",
        "updatedAt": null
      },
      {
        "id": "20",
        "title": "实现战斗 UI (BattleScreen)",
        "description": "Godot 场景实现战斗界面:手牌/能量/状态/敌人意图/目标选择",
        "details": "创建 Game.Godot/Scenes/Battle/BattleScreen.tscn:\n- 布局:\n  - 左侧: 英雄列表(HP/护盾/状态图标)\n  - 右侧: 敌人列表(HP/护盾/意图预告)\n  - 底部: 手牌区(CardView 组件)、能量显示、结束回合按钮\n- CardView 组件:\n  - 显示卡牌名称/消耗/描述/类型图标\n  - 可拖拽或点击选择,选中后进入目标选择模式\n- 目标选择:\n  - 根据卡牌 TargetRule 高亮可选目标\n  - 点击目标触发 PlayCard 用例\n- 订阅 Core 事件刷新 UI:\n  - CardPlayed → 更新手牌\n  - core.effect.resolved → 播放受击动画与血条更新\n  - core.effect.resolved → 刷新状态图标\n  - core.battle.ended/core.battle.ended → 切换到奖励/结算界面\n脚本: Game.Godot/Scripts/Battle/BattleScreenController.cs(调用 BattleManager 用例)。\n\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "GdUnit4 场景测试:\n- 验证场景可正常加载\n- 模拟 CardPlayed 事件触发 UI 刷新\n- 验证结束回合按钮可点击并调用 BattleManager.EndPlayerTurn\n手动冒烟: 出牌 → 目标选择 → 伤害数字 → 敌人死亡 → 胜利",
        "priority": "high",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "BattleScreen 场景布局与基础组件搭建",
            "description": "创建 BattleScreen.tscn 场景,实现英雄列表、敌人列表、手牌区、能量显示等基础 UI 布局和组件",
            "dependencies": [],
            "details": "在 Game.Godot/Scenes/Battle/ 目录创建 BattleScreen.tscn 场景文件。布局划分为三个主区域:(1)左侧英雄列表区域,每个英雄显示 HP/护盾/状态图标,使用 VBoxContainer 垂直排列;(2)右侧敌人列表区域,显示敌人 HP/护盾/意图预告,同样使用 VBoxContainer;(3)底部手牌区域,包含 CardView 组件容器(HBoxContainer)、能量显示标签(Label)和结束回合按钮(Button)。创建 UnitStatusView.tscn 复用组件显示单个单位(英雄/敌人)的 HP 条、护盾值、状态图标列表。使用 Control 节点作为根节点,设置合理的布局锚点和边距。通过 GdUnit4 验证场景可正常加载且所有子节点可访问。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试:验证 BattleScreen.tscn 加载无误,检查左侧英雄列表容器存在,右侧敌人列表容器存在,底部手牌区容器存在,结束回合按钮可点击。验证 UnitStatusView 组件可实例化并正确显示 HP/护盾标签。"
          },
          {
            "id": "2",
            "title": "CardView 卡牌组件与目标选择高亮实现",
            "description": "创建 CardView 复用组件,支持卡牌显示、拖拽/点击选中,实现根据 TargetRule 的目标高亮逻辑",
            "dependencies": [
              "1"
            ],
            "details": "在 Game.Godot/Scenes/Battle/ 创建 CardView.tscn 复用场景和 CardViewController.cs 脚本。CardView 显示卡牌的名称(Label)、消耗能量(Label)、描述文本(RichTextLabel)、类型图标(TextureRect)。实现选中状态(改变 modulate 颜色或添加边框);实现拖拽逻辑(监听 gui_input,记录拖拽起点,触发自定义信号 card_selected);实现点击选中逻辑(无拖拽时触发选中状态)。在 BattleScreenController.cs 中实现目标选择高亮:当卡牌被选中时,根据 CardDefinition.TargetRule 枚举值(SingleEnemy/AllEnemies/SingleAlly/AllAllies)高亮对应的单位(改变单位 modulate 颜色或添加高亮框),点击高亮目标触发 PlayCard 用例调用。通过 GdUnit4 验证 CardView 可正常加载、显示卡牌信息、选中状态正确切换、拖拽信号正确发送。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试:加载 CardView 组件,验证卡牌名称/消耗/描述显示正确;模拟点击 CardView 验证选中信号(card_selected)发送;模拟拖拽验证 gui_input 事件处理;在 BattleScreen 中模拟选择卡牌,验证敌人列表中对应 TargetRule 的单位被高亮(modulate 颜色改变)。"
          },
          {
            "id": "3",
            "title": "事件订阅与 UI 自动刷新(CardPlayed/core.effect.resolved/core.effect.resolved/core.battle.ended)",
            "description": "在 BattleScreenController 中订阅 Core 事件,实现手牌更新、伤害动画、状态图标刷新、战斗结束切换等 UI 响应逻辑",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "在 BattleScreenController.cs 中注册事件监听器:订阅 BattleManager.CardPlayed 事件更新手牌显示(移除已出卡牌、重新排列剩余卡牌);订阅 BattleManager.core.effect.resolved 事件播放受击动画(目标单位闪烁或缩放动画,使用 Tween)与更新 HP 条;订阅 BattleManager.core.effect.resolved 事件刷新对应单位的状态图标列表;订阅 BattleManager.core.battle.ended/core.battle.ended 事件切换到 RewardPanel/GameOverPanel(隐藏 BattleScreen,显示奖励/结算界面)。确保事件解绑在 _ExitTree() 中正确执行以避免内存泄漏。通过 GdUnit4 验证事件刷新逻辑正确触发。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试:加载 BattleScreen 场景;模拟 CardPlayed 事件,验证手牌容器中对应卡牌被移除并 UI 重新布局;模拟 core.effect.resolved 事件,验证受击单位 HP 条数值更新且播放动画(Tween active);模拟 core.effect.resolved 事件,验证对应单位状态图标容器新增状态图标;模拟 core.battle.ended 事件,验证 RewardPanel 显示且 BattleScreen 隐藏;验证事件解绑后事件不再触发 UI 刷新。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on 实现战斗 UI (BattleScreen).",
        "updatedAt": null
      },
      {
        "id": "21",
        "title": "实现地图 UI (MapScreen)",
        "description": "Godot 场景实现地图界面:节点渲染/连线/选择/进入",
        "details": "创建 Game.Godot/Scenes/Map/MapScreen.tscn:\n- 布局:\n  - 中央: 节点图(分层节点 + 连线)\n  - 顶部: 队伍信息(金币/英雄 HP)\n- 节点渲染:\n  - 每个 MapNode 绘制为图标(战斗/事件/休息/商店/精英/Boss)\n  - 当前节点高亮\n  - 可达节点可点击,不可达节点置灰\n  - 已完成节点显示勾选标记\n- 连线绘制:\n  - 使用 Line2D 或自定义绘制连线\n- 节点点击:\n  - 点击可达节点 → 调用 RunManager.EnterNode → 切换到对应场景(BattleScreen/EventDialog/RestPanel/ShopPanel)\n脚本: Game.Godot/Scripts/Map/MapScreenController.cs(调用 RunManager 用例)。\n\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "GdUnit4 场景测试:\n- 验证场景加载\n- 模拟点击节点触发 EnterNode 事件\n手动冒烟: 地图显示 → 点击节点 → 进入战斗/事件 → 完成后回地图 → 下一层节点解锁",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "MapScreen 场景布局与节点数据结构展示",
            "description": "创建 MapScreen.tscn 场景文件，实现分层节点图布局、当前节点高亮、完成标记展示及队伍信息面板",
            "dependencies": [],
            "details": "在 Game.Godot/Scenes/Map/ 创建 MapScreen.tscn，包含：(1) 顶部 HBoxContainer 显示队伍信息（金币、英雄 HP）；(2) 中央 Control 节点作为节点图容器；(3) 根据 RunManager 的当前地图数据加载节点，每个节点用 Control + Icon 绘制，应用不同视觉状态（可达/不可达/当前/已完成）；(4) 实现 _ready() 初始化场景、_process() 更新节点状态；(5) 创建对应的 MapScreenController.cs 脚本绑定到根节点。需确保节点位置计算正确支持分层显示。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：验证场景加载、检查顶部信息面板可见、验证节点容器包含正确数量的节点子项、检查当前节点被正确高亮、验证已完成节点显示勾选标记、验证不可达节点置灰显示。手动冒烟：启动地图场景，验证布局正确、信息面板显示、节点视觉状态准确。"
          },
          {
            "id": "2",
            "title": "节点连线渲染与点击交互实现",
            "description": "实现连线的绘制（Line2D 或自定义绘制）及节点点击事件处理，支持可达节点交互",
            "dependencies": [
              "1"
            ],
            "details": "在 MapScreenController.cs 中：(1) 使用 Line2D 节点连接相邻节点，或通过 _draw() 自定义绘制连线；(2) 根据节点可达性设置连线颜色（可达绿色、不可达灰色）；(3) 为每个节点 Control 绑定 gui_input 信号，在点击事件中检查节点是否可达；(4) 可达节点添加 pressed 或 mouse_entered 视觉反馈（缩放、发光等）；(5) 记录点击状态供后续 EnterNode 调度使用。需确保连线与节点位置同步更新，处理动态节点添加场景。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：模拟在不同节点上进行 gui_input 点击事件、验证可达节点触发交互、验证不可达节点点击无响应、检查连线绘制正确连接节点、验证连线颜色按可达性正确显示。手动冒烟：点击可达节点检查视觉反馈、点击不可达节点无反应、通过地图验证连线清晰可见。"
          },
          {
            "id": "3",
            "title": "EnterNode 调度与场景切换",
            "description": "实现节点点击后的 RunManager.EnterNode 调用，根据节点类型切换到对应场景（BattleScreen/EventDialog/RestPanel/ShopPanel）",
            "dependencies": [
              "2"
            ],
            "details": "在 MapScreenController.cs 中：(1) 在节点点击处理中获取节点的 type（Battle/Event/Rest/Shop/Elite/Boss）；(2) 调用 RunManager.EnterNode(nodeId)，该方法内部根据 type 加载对应场景；(3) 使用 get_tree().change_scene_to_file() 或 get_tree().root.add_child() 切换场景，确保切换前保存 MapScreen 状态；(4) 各场景退出时通过信号或回调通知 RunManager，返回地图场景并更新节点状态（标记已完成、解锁下一层）；(5) 处理场景切换的加载动画或淡入淡出效果；(6) 记录节点进入日志便于调试。确保场景切换流畅、状态同步。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：模拟点击各类型节点（战斗/事件/休息/商店/精英/Boss）、验证 RunManager.EnterNode 被正确调用、验证场景正确切换（使用 get_tree().current_scene 检查）、模拟场景返回并验证节点标记更新、检查下一层节点解锁逻辑。手动冒烟：完整流程测试（点击节点→进入场景→完成→返回地图→验证状态更新→进入下一层）、验证各场景类型的正确进入。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on 实现地图 UI (MapScreen).",
        "updatedAt": null
      },
      {
        "id": "22",
        "title": "实现奖励选择 UI (RewardPanel)",
        "description": "战后奖励界面:选卡加入牌组/金币展示",
        "details": "创建 Game.Godot/Scenes/Reward/RewardPanel.tscn:\n- 布局:\n  - 顶部: \"战斗胜利!\" 标题\n  - 中央: 3 张候选卡牌(CardView 组件)\n  - 底部: 金币奖励文本、\"跳过\" 按钮\n- 交互:\n  - 点击卡牌 → 调用 Party.GetHero(heroId).Deck.AddCard(cardDef)\n  - 点击跳过或选择卡牌后 → 关闭面板,回到地图\n- 订阅 core.battle.ended 事件打开面板:\n  - 从 RewardManager 获取候选卡与金币\n脚本: Game.Godot/Scripts/Reward/RewardPanelController.cs。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "GdUnit4 场景测试:\n- 验证面板显示候选卡\n- 模拟点击卡牌触发 AddCard 事件\n手动冒烟: 战斗胜利 → 奖励面板弹出 → 选卡 → 牌组中新增卡牌",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 RewardPanel.tscn 场景布局",
            "description": "创建奖励面板的主场景文件，包含顶部标题、中央卡牌区域、底部金币和跳过按钮的布局框架",
            "dependencies": [],
            "details": "在 Game.Godot/Scenes/Reward/ 目录下创建 RewardPanel.tscn 文件。使用 VBoxContainer 作为主容器，布局包括：顶部 Label('战斗胜利!')、中央 HBoxContainer 容纳 3 个 CardView 组件、底部 HBoxContainer 包含金币文本显示和跳过按钮。设置合理的间距、对齐方式和字体大小。确保布局在不同分辨率下适配。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：加载 RewardPanel.tscn，验证所有 UI 元素存在、可见性正确、布局层级一致"
          },
          {
            "id": "2",
            "title": "实现 RewardPanelController 脚本与卡牌选择交互",
            "description": "编写 RewardPanelController.cs 脚本，实现卡牌点击交互逻辑，将选中的卡牌添加到英雄牌组",
            "dependencies": [
              "1"
            ],
            "details": "创建 Game.Godot/Scripts/Reward/RewardPanelController.cs。脚本需要：1) 获取 3 个 CardView 的引用并为每个卡牌点击按钮连接信号处理；2) 在点击卡牌时调用 Party.GetHero(heroId).Deck.AddCard(cardDef)；3) 点击后触发面板关闭逻辑。定义 OnCardSelected(cardDef) 方法处理卡牌选择，定义 ClosePanel() 方法关闭面板并返回地图。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：模拟点击卡牌，验证 AddCard 方法是否被正确调用；验证点击后面板关闭"
          },
          {
            "id": "3",
            "title": "实现跳过按钮交互与面板关闭逻辑",
            "description": "为跳过按钮添加点击处理，实现直接关闭奖励面板并返回地图场景的功能",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "在 RewardPanelController 中为跳过按钮添加点击信号连接。实现 OnSkipPressed() 方法，直接调用面板关闭逻辑（隐藏面板、发送返回地图信号或场景切换）。确保卡牌选择和跳过都会触发相同的面板关闭流程，避免重复代码。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：模拟跳过按钮点击，验证面板是否关闭；验证返回地图的信号是否正确发送"
          },
          {
            "id": "4",
            "title": "订阅 core.battle.ended 事件并集成 RewardManager",
            "description": "连接 core.battle.ended 事件，从 RewardManager 获取奖励数据，将候选卡牌和金币填充到 UI",
            "dependencies": [
              "1",
              "3"
            ],
            "details": "在 RewardPanelController 中注册 core.battle.ended 事件监听（可使用全局事件总线或 Autoload）。事件触发时调用 RewardManager.GenerateCardRewards(heroClassId, 3) 获取候选卡牌和 GenerateGoldReward(nodeType) 获取金币数量。将候选卡牌分配给 3 个 CardView 组件，更新底部金币显示文本。打开/显示面板。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：模拟发送 core.battle.ended 事件，验证面板显示、候选卡牌加载、金币数值正确显示"
          },
          {
            "id": "5",
            "title": "编写完整的冒烟测试与手动验收清单",
            "description": "编写 GdUnit4 集成测试覆盖完整流程，并准备手动冒烟测试步骤确保功能可玩性",
            "dependencies": [
              "2",
              "3",
              "4"
            ],
            "details": "创建 Tests/Scenes/Reward/test_reward_panel.gd GdUnit4 测试文件，测试场景包括：1) 面板加载与初始状态；2) 三张卡牌正确显示；3) 点击卡牌触发 AddCard 并关闭面板；4) 点击跳过直接关闭面板；5) core.battle.ended 事件触发面板打开并填充数据。手动冒烟步骤：启动游戏 → 进行战斗 → 战斗胜利 → 奖励面板弹出 → 验证卡牌显示与金币数值 → 选择或跳过 → 返回地图。记录截图和结果。",
            "status": "pending",
            "testStrategy": "GdUnit4 多场景集成测试与手动 E2E 冒烟；验证面板显示、交互响应、状态管理、返回流程"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现奖励选择 UI (RewardPanel).",
        "updatedAt": null
      },
      {
        "id": "23",
        "title": "实现事件对话框 UI (EventDialog)",
        "description": "事件节点展示文本与选项按钮",
        "details": "创建 Game.Godot/Scenes/Event/EventDialog.tscn:\n- 布局:\n  - 中央: 事件文本框(RichTextLabel)\n  - 底部: 2–3 个选项按钮(动态生成)\n- 交互:\n  - 加载事件时从 EventManager 获取 EventDefinition\n  - 根据 Options 动态创建按钮\n  - 按钮文本从本地化 key 获取(或暂时硬编码)\n  - 点击选项 → 调用 EventManager.SelectOption → 执行 Effects → 关闭对话框回地图\n- 条件选项:\n  - 金币不足时按钮置灰并显示提示\n脚本: Game.Godot/Scripts/Event/EventDialogController.cs。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "GdUnit4 场景测试:\n- 验证事件文本与选项按钮正确显示\n- 模拟点击选项触发 SelectOption 事件\n手动冒烟: 进入事件节点 → 对话框弹出 → 点击选项 → Effects 生效 → 回地图",
        "priority": "medium",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 EventDialog.tscn 场景与布局",
            "description": "创建事件对话框场景文件,实现 UI 布局包括事件文本框和动态选项按钮容器。",
            "dependencies": [],
            "details": "在 Game.Godot/Scenes/Event/ 目录下创建 EventDialog.tscn 场景:\n- 根节点: Control 或 CanvasLayer\n- 布局结构:\n  - 中央: RichTextLabel(event_text_display) 用于显示事件文本,支持富文本格式\n  - 底部: VBoxContainer(options_container) 用于动态创建选项按钮,预留 2-3 个按钮空间\n  - 样式: 设置合适的边距、对齐和背景颜色\n- 配置:\n  - 设置 RichTextLabel 的 bbcode_enabled = true\n  - 为 options_container 配置合适的分离线距离\n  - 测试场景在 Godot 编辑器中的可视化效果\n- 验收标准: 场景能在编辑器中正确加载,布局在不同分辨率下合理显示,无脚本错误",
            "status": "pending",
            "testStrategy": "手动冒烟: 在 Godot 编辑器中打开场景,验证 UI 元素正确显示和布局合理。可选使用 GdUnit4 验证场景节点存在性和初始状态。"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 4,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Break down this task with a focus on 实现事件对话框 UI (EventDialog).",
        "updatedAt": null
      },
      {
        "id": "24",
        "title": "实现休息界面 UI (RestPanel)",
        "description": "休息节点二选一:回血/升级卡",
        "details": "创建 Game.Godot/Scenes/Rest/RestPanel.tscn:\n- 布局:\n  - 顶部: \"休息营地\" 标题\n  - 中央: 两个大按钮(\"回复生命\" / \"升级卡牌\")\n- 交互:\n  - 点击 \"回复生命\" → 调用 RestService.HealParty → 关闭面板回地图\n  - 点击 \"升级卡牌\" → 打开牌组选择器(选择一张卡升级)→ 调用 RestService.UpgradeCard → 关闭面板回地图\n- 牌组选择器(可复用后续构筑界面组件):\n  - 展示英雄牌组所有卡牌\n  - 点击一张卡 → 确认升级\n脚本: Game.Godot/Scripts/Rest/RestPanelController.cs。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "GdUnit4 场景测试:\n- 验证两个按钮可点击\n- 模拟点击回血触发 HealParty 事件\n手动冒烟: 进入休息节点 → 选择回血/升级 → 效果生效 → 回地图",
        "priority": "low",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 RestPanel.tscn 场景布局与基础 UI",
            "description": "创建 Game.Godot/Scenes/Rest/RestPanel.tscn 场景文件，实现顶部标题、中央两个大按钮的布局和样式",
            "dependencies": [],
            "details": "使用 Godot Control 节点创建层级：VBoxContainer(根)→ Label(标题\"休息营地\") + HBoxContainer(两个 Button：\"回复生命\" / \"升级卡牌\")。应用主题/皮肤保持 UI 一致性。设置按钮大小与间距。",
            "status": "pending",
            "testStrategy": "GdUnit4：验证场景加载成功、两个按钮节点存在且可见、标题文本正确"
          },
          {
            "id": "2",
            "title": "实现 RestPanelController.cs 与回血交互",
            "description": "创建 Game.Godot/Scripts/Rest/RestPanelController.cs，实现\"回复生命\"按钮点击事件与 RestService.HealParty 调用",
            "dependencies": [
              "1"
            ],
            "details": "在 RestPanelController 中连接\"回复生命\"按钮的 pressed 信号 → 调用 RestService.HealParty() → 等待完成后关闭 RestPanel 并返回地图。需要处理 RestService 的异步回调或信号。",
            "status": "pending",
            "testStrategy": "xUnit：验证 RestService.HealParty 被正确调用。GdUnit4：模拟点击按钮，验证 HealParty 信号或事件触发、面板关闭"
          },
          {
            "id": "3",
            "title": "实现牌组选择器组件 CardSelectorPanel",
            "description": "创建可复用的牌组选择器场景与控制器，展示英雄当前牌组所有卡牌，支持选中与确认",
            "dependencies": [
              "1"
            ],
            "details": "创建 Game.Godot/Scenes/Rest/CardSelectorPanel.tscn 与 CardSelectorController.cs。使用 ItemList 或 GridContainer 展示卡牌列表（包括卡牌名称、稀有度图标）。实现选中高亮、确认按钮逻辑。通过信号返回选中的 CardInstance。",
            "status": "pending",
            "testStrategy": "GdUnit4：验证卡牌列表正确加载、点击卡牌高亮、点击确认返回选中卡牌数据"
          },
          {
            "id": "4",
            "title": "实现\"升级卡牌\"交互与完整流程",
            "description": "连接\"升级卡牌\"按钮到牌组选择器，实现选卡→升级→关闭的完整流程",
            "dependencies": [
              "2",
              "3"
            ],
            "details": "在 RestPanelController 中连接\"升级卡牌\"按钮 → 打开 CardSelectorPanel → 监听选中信号 → 调用 RestService.UpgradeCard(selectedCard) → 等待完成 → 关闭选择器与 RestPanel、返回地图。处理取消升级的逻辑。",
            "status": "pending",
            "testStrategy": "GdUnit4：模拟完整流程（点击升级→选卡→确认→验证 UpgradeCard 调用→面板关闭）"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on 实现休息界面 UI (RestPanel).",
        "updatedAt": null
      },
      {
        "id": "25",
        "title": "实现商店界面 UI (ShopPanel)",
        "description": "商店节点:购买卡牌/移除卡牌",
        "details": "创建 Game.Godot/Scenes/Shop/ShopPanel.tscn:\n- 布局:\n  - 顶部: 金币显示\n  - 左侧: 售卖卡牌列表(CardView + 价格)\n  - 右侧: \"移除卡牌\" 按钮\n  - 底部: \"离开商店\" 按钮\n- 交互:\n  - 进入商店时调用 ShopService.GenerateShopInventory 生成商品\n  - 点击卡牌 → 调用 ShopService.PurchaseCard → 扣金币加牌 → 刷新金币显示\n  - 点击 \"移除卡牌\" → 打开牌组选择器 → 选择一张卡 → 调用 ShopService.RemoveCard → 扣金币移牌\n  - 金币不足时购买/移除按钮置灰\n  - 点击 \"离开商店\" → 关闭面板回地图\n脚本: Game.Godot/Scripts/Shop/ShopPanelController.cs。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Shop-DTOs.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md; docs/architecture/overlays/PRD-rouge-manager/08/_index.md",
        "testStrategy": "GdUnit4 场景测试:\n- 验证商品列表生成\n- 模拟购买触发 PurchaseCard 事件\n- 金币不足时按钮置灰\n手动冒烟: 进入商店 → 购买卡/移除卡 → 金币变化 → 牌组变化 → 离开回地图",
        "priority": "low",
        "dependencies": [
          "15"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 ShopPanel.tscn 场景布局与 ShopPanelController.cs 脚本",
            "description": "创建商店面板场景文件和控制器脚本,建立完整的 UI 框架和事件绑定基础",
            "dependencies": [
              "15"
            ],
            "details": "在 Game.Godot/Scenes/Shop/ 下创建 ShopPanel.tscn 场景:\n1. 创建根节点 Control (ShopPanel)\n2. 添加顶部 Label 显示金币(绑定 GoldAmount)\n3. 添加左侧 GridContainer 容器用于卡牌列表显示\n4. 添加右侧 VBoxContainer 包含 '移除卡牌' 按钮\n5. 添加底部 '离开商店' 按钮\n6. 创建 Game.Godot/Scripts/Shop/ShopPanelController.cs:\n   - 继承 Control\n   - 声明信号: on_card_purchased, on_card_removed, on_shop_closed\n   - 实现 _Ready() 初始化 UI 组件引用\n   - 实现 _on_card_button_pressed(cardInstance) 事件处理器\n   - 实现 _on_remove_card_button_pressed() 事件处理器\n   - 实现 _on_leave_shop_button_pressed() 事件处理器\n   - 实现 UpdateGoldDisplay(amount) 方法\n   - 实现 SetButtonEnabled(button, enabled) 方法\n7. 使用 GDScript/C# Adapter 模式注入 ShopService 依赖",
            "status": "pending",
            "testStrategy": "xUnit + GdUnit4:\n- 单元测试: ShopPanelControllerTests 验证按钮事件信号触发\n- 场景测试: test_shop_panel.gd 验证布局正确性、节点可见性、信号连接"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Break down this task with a focus on 实现商店界面 UI (ShopPanel).",
        "updatedAt": null
      },
      {
        "id": "26",
        "title": "实现主菜单与开局流程 UI (MainMenu)",
        "description": "主菜单提供开始新局/继续/设置功能",
        "details": "创建 Game.Godot/Scenes/MainMenu.tscn:\n- 布局:\n  - 中央: 游戏标题\n  - 按钮:\n    - \"开始新局\": 调用 RunManager.StartNewRun(随机 Seed) → 切换到 MapScreen\n    - \"继续\" (可选): 加载存档 → 切换到 MapScreen(T2 可先占位不实现)\n    - \"设置\": 打开设置面板(音量等,可复用现有 SettingsPanel)\n    - \"退出\": 退出游戏\n- 开局流程:\n  - 点击 \"开始新局\" → (可选)选择初始英雄与职业 → 生成初始牌组 → StartNewRun → 进入地图\n  - T2 可简化为固定 2 名英雄(战士 + 法师)直接开局\n脚本: Game.Godot/Scripts/MainMenuController.cs。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "GdUnit4 场景测试:\n- 验证按钮可点击\n- 模拟点击开始新局触发 StartNewRun 事件\n手动冒烟: 主菜单 → 开始新局 → 地图界面加载成功",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 MainMenu.tscn 场景与按钮布局",
            "description": "在 Game.Godot/Scenes 目录创建主菜单场景文件,包含游戏标题、四个功能按钮(开始新局/继续/设置/退出)的视觉布局和基础信号连接",
            "dependencies": [],
            "details": "创建 MainMenu.tscn 场景:\n- 根节点: Control(全屏)\n- 子节点结构:\n  - VBoxContainer(中央对齐): 包含标题与按钮\n    - Label: 游戏标题(字体大小 48px,居中)\n    - VBoxContainer: 四个按钮容器\n      - Button: \"开始新局\"(连接 pressed 信号)\n      - Button: \"继续\"(暂时禁用或占位)\n      - Button: \"设置\"(连接 pressed 信号)\n      - Button: \"退出\"(连接 pressed 信号)\n- 添加 ColorRect 背景(深灰/黑色)\n- 使用 Godot Theme 统一按钮样式\n- 附加 MainMenuController.cs 脚本到根节点\n参考现有菜单模式(SettingsPanel),保持样式一致性",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试:\n- 验证场景加载无错误\n- 验证四个按钮可见且可点击\n- 验证按钮信号正确连接\n手动验证: 启动游戏后主菜单显示完整,按钮响应鼠标悬停效果"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 4,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Break down this task with a focus on 实现主菜单与开局流程 UI (MainMenu).",
        "updatedAt": null
      },
      {
        "id": "27",
        "title": "实现结算界面 UI (RunEndScreen)",
        "description": "胜利/失败结算展示统计数据与重开按钮",
        "details": "创建 Game.Godot/Scenes/RunEnd/RunEndScreen.tscn:\n- 布局:\n  - 顶部: 结果标题(\"胜利!\" / \"失败\")\n  - 中央: 统计数据(可选):\n    - 用时、击杀数、获得卡牌数、最终金币\n  - 底部: \"重新开始\" 按钮、\"返回主菜单\" 按钮\n- 交互:\n  - 订阅 RunEnded 事件打开界面\n  - 点击 \"重新开始\" → 调用 RunManager.StartNewRun(新 Seed) → 回到地图\n  - 点击 \"返回主菜单\" → 切换到 MainMenu\n脚本: Game.Godot/Scripts/RunEnd/RunEndScreenController.cs。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "GdUnit4 场景测试:\n- 验证胜利/失败文本正确显示\n- 模拟点击重新开始触发 StartNewRun 事件\n手动冒烟: Boss 胜利/全灭 → 结算界面弹出 → 重开下一局 → 地图重新生成",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "创建 RunEndScreen.tscn 场景与 UI 布局",
            "description": "创建游戏结算界面场景文件，包含顶部结果标题、中央统计数据面板、底部操作按钮的完整布局",
            "dependencies": [],
            "details": "在 Game.Godot/Scenes/RunEnd/ 目录创建 RunEndScreen.tscn 场景：\n1. 顶部 Label 显示胜利/失败文本（Victory/Defeat）\n2. 中央 VBoxContainer 包含统计数据：\n   - 用时（Duration）Label\n   - 击杀敌人数（EnemiesDefeated）Label\n   - 获得卡牌数（CardsAcquired）Label\n   - 最终金币（FinalGold）Label\n3. 底部 HBoxContainer 包含两个 Button：\n   - \"重新开始\" 按钮（restart_button）\n   - \"返回主菜单\" 按钮（main_menu_button）\n使用 Theme 资源确保风格统一，参考现有 UI 屏幕（如 MapScreen）的设计模式。使用相对布局（Anchor/Margin）适配不同分辨率。",
            "status": "pending",
            "testStrategy": "GdUnit4 场景测试：验证场景加载、所有子节点存在、Button 节点可引用、Label 初始文本为空"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 4,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Break down this task with a focus on 实现结算界面 UI (RunEndScreen).",
        "updatedAt": null
      },
      {
        "id": "28",
        "title": "实现存档与读档功能 (DataStore 集成)",
        "description": "利用 DataStore Autoload 保存/加载 RunGameState",
        "details": "扩展 Game.Godot/Adapters/DataStoreAdapter.cs:\n- 方法:\n  - SaveRun(runState): 将 RunGameState 序列化为 JSON 并写入 user://saves/current_run.json\n  - LoadRun(): 从文件读取并反序列化为 RunGameState\n  - HasSave(): 检查存档是否存在\n- 调用时机:\n  - 每次节点完成后自动保存(CompleteNode 后)\n  - 主菜单 \"继续\" 按钮加载存档\n- 版本迁移:\n  - 检查 Version 字段,若版本不匹配提示用户或自动迁移(T2 可先简单校验版本号一致)\n脚本调用: RunManager.CompleteNode → DataStore.SaveRun。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit 单元测试:\n- DataStoreAdapterTests: 验证 SaveRun/LoadRun 序列化一致性\n- 版本校验测试: 老版本数据加载失败或迁移\nGdUnit4 集成测试:\n- 完成节点后文件 user://saves/current_run.json 存在\n- 重启游戏后继续加载存档正确恢复地图进度与牌组",
        "priority": "low",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "实现 DataStoreAdapter 核心序列化方法",
            "description": "扩展 Game.Godot/Adapters/DataStoreAdapter.cs，实现 SaveRun()、LoadRun() 和 HasSave() 方法，支持 RunGameState 的 JSON 序列化与反序列化，集成版本字段校验",
            "dependencies": [],
            "details": "实现以下方法：\n1. SaveRun(RunGameState): 使用 System.Text.Json 将 RunGameState 序列化为 JSON，写入 user://saves/current_run.json，确保 Version 字段正确保存\n2. LoadRun(): 读取 user://saves/current_run.json，反序列化为 RunGameState 对象，返回完整状态\n3. HasSave(): 检查 user://saves/current_run.json 是否存在\n4. VerifyVersion(): 检查保存的版本号与当前版本是否匹配，不匹配时抛出异常或返回迁移提示\n\n确保代码遵循 Game.Core 纯 C# 约定，不依赖 Godot API。测试用例验证序列化的完整性与一致性。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：\n- DataStoreAdapterTests.SaveRun_SerializesValidState：验证 RunGameState 序列化无损\n- DataStoreAdapterTests.LoadRun_DeserializesCorrectly：验证反序列化与原始对象相同\n- DataStoreAdapterTests.HasSave_ChecksFileExistence：验证文件存在判断逻辑\n- DataStoreAdapterTests.VerifyVersion_ThrowsOnMismatch：版本不匹配时抛出异常"
          },
          {
            "id": "2",
            "title": "集成 RunManager 与 DataStore 的存档调用链",
            "description": "修改 RunManager，在 CompleteNode() 后自动调用 DataStore.SaveRun()，确保每次节点完成都触发自动存档，并添加信号通知存档成功",
            "dependencies": [
              "1"
            ],
            "details": "实现以下改动：\n1. 在 RunManager.CompleteNode() 方法末尾添加 DataStore.SaveRun(CurrentRunState) 调用\n2. 添加错误处理，捕获序列化或文件写入异常，记录日志但不中断游戏流程\n3. 发射新信号 RunStateSaved(RunGameState) 用于 UI 反馈\n4. 主菜单 \"继续\" 按钮调用 DataStore.LoadRun() 和 HasSave() 检查存档可用性\n5. 加载存档时验证 RunGameState 的完整性（检查关键字段是否为空）\n\n确保调用链完整且可追溯。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：\n- RunManagerIntegrationTests.CompleteNode_CallsSaveRun：验证 CompleteNode 后触发 SaveRun\n- RunManagerIntegrationTests.CompleteNode_EmitsSavedSignal：验证 RunStateSaved 信号被正确发射\n- RunManagerIntegrationTests.LoadRun_RestoresState：验证加载的 RunGameState 与保存时一致\n- RunManagerIntegrationTests.HasSave_ReturnsFalseWhenNoFile：无存档时正确返回 false\n\nGdUnit4 集成测试：\n- 完成节点后验证 user://saves/current_run.json 文件存在\n- 重启场景后继续加载存档，验证游戏状态正确恢复"
          },
          {
            "id": "3",
            "title": "实现版本迁移与向后兼容性校验",
            "description": "添加版本迁移逻辑处理旧版本存档的兼容性问题，包括版本号检查、数据兼容性验证和用户提示机制",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "实现以下功能：\n1. 在 RunGameState 中添加 Version 字段（如 \"1.0\"）\n2. SaveRun() 时自动写入当前版本号\n3. LoadRun() 时检查保存的版本号：\n   - 版本相同：正常加载\n   - 版本不同：返回 VersionMismatchException 异常或标记兼容性警告\n4. 设计版本迁移策略（初期可简单校验版本号一致，T2 后扩展为数据字段升级）\n5. 为版本不兼容的存档提供清晰用户提示（如 \"存档版本过旧，请重新开始游戏\"）\n6. 在主菜单中显示存档的版本信息和兼容性状态\n\n文档记录版本迁移规则便于未来扩展。",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：\n- VersionMigrationTests.LoadRun_VersionMismatch_ThrowsException：版本不匹配时抛异常\n- VersionMigrationTests.SaveRun_WritesCurrentVersion：保存时写入正确版本号\n- VersionMigrationTests.VersionCompatibility_OlderVersion_Handled：旧版本存档处理逻辑\n- VersionMigrationTests.VersionCompatibility_NewerVersion_Handled：新版本存档处理逻辑\n\nGdUnit4 集成测试：\n- 加载版本不兼容的存档文件，验证错误提示显示在主菜单\n- 版本升级后加载旧存档，验证迁移逻辑正确执行"
          }
        ],
        "adrRefs": [
          "ADR-0006",
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH05",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down this task with a focus on 实现存档与读档功能 (DataStore 集成).",
        "updatedAt": null
      },
      {
        "id": "29",
        "title": "编写 E2E 可玩闭环冒烟测试",
        "description": "自动化或手动验证完整流程:开局→选路→战斗→奖励→Boss→结算→重开",
        "details": "创建 GdUnit4 E2E 测试套件 tests/e2e/test_mvp_run.gd:\n- 测试流程:\n  1. 模拟点击主菜单 \"开始新局\" → 验证进入 MapScreen\n  2. 模拟点击战斗节点 → 验证进入 BattleScreen\n  3. 模拟出牌 → 验证敌人 HP 下降、手牌移动\n  4. 模拟结束回合 → 验证敌方回合执行意图\n  5. 模拟敌人全灭 → 验证 core.battle.ended 事件触发、RewardPanel 打开\n  6. 模拟选择卡牌奖励 → 验证牌组新增卡牌\n  7. 回到地图 → 验证当前节点标记完成、下一层节点可点击\n  8. 重复步骤 2–7 直到 Boss 节点\n  9. 模拟 Boss 战胜利 → 验证 RunEndScreen 显示胜利\n  10. 模拟点击 \"重新开始\" → 验证回到地图且地图重新生成\n- 或编写手动冒烟测试清单(docs/testing/mvp-smoke-test.md)供 QA 执行。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "GdUnit4 场景集成测试:\n- test_mvp_run.gd: 完整流程自动化测试\n手动冒烟:\n- 执行完整流程并记录通过/失败\n通过标准: 无崩溃、无卡死、所有节点类型可正常完成、Boss 胜利后可重开",
        "priority": "high",
        "dependencies": [
          "20",
          "21",
          "22",
          "23",
          "26",
          "27"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "设计 GdUnit4 E2E 测试架构与基础场景",
            "description": "创建 tests/e2e/ 目录结构，设计可复现的测试场景模板，包括主菜单、地图、战斗三个基础场景的 headless 初始化与清理逻辑。",
            "dependencies": [],
            "details": "在 tests/e2e/test_mvp_run.gd 中实现：(1) 测试套件初始化，加载主菜单场景 res://Scenes/MainMenu.tscn；(2) 定义辅助方法 setup_new_game()、cleanup_scene()；(3) 验证各场景可在 headless 模式下加载，无崩溃、无缺失依赖。输出：tests/e2e/test_mvp_run.gd 框架代码，通过基础冒烟。",
            "status": "pending",
            "testStrategy": "GdUnit4 集成测试：验证主菜单、地图、战斗三个场景在 headless 下可成功加载；断言：visible=true，无异常日志"
          },
          {
            "id": "2",
            "title": "实现主菜单到地图的流程测试（开局→选路）",
            "description": "测试玩家点击 '开始新局' 按钮后完整流程：验证进入 MapScreen、初始化地图节点、第一层节点可点击。",
            "dependencies": [
              "1"
            ],
            "details": "在 test_mvp_run.gd 中实现 test_new_game_flow()：(1) 模拟点击主菜单 '开始新局' 按钮；(2) 等待场景转换，验证 MapScreen 可见；(3) 验证 MapScreen 初始化：第 1 层节点列表长度 ≥3，所有节点类型（普通战斗/精英/宝箱/Boss）正确显示；(4) 验证第 1 个节点状态为 Accessible，可点击。断言：地图已加载、第一层节点可交互。",
            "status": "pending",
            "testStrategy": "GdUnit4：模拟 UI 输入，验证场景转换、节点状态、可交互性；检查无重复节点、节点坐标正确"
          },
          {
            "id": "3",
            "title": "实现战斗流程核心逻辑测试（战斗→奖励）",
            "description": "测试点击地图节点进入战斗、玩家出牌、敌方回合、战斗胜利、奖励选择的完整闭环流程。",
            "dependencies": [
              "2"
            ],
            "details": "在 test_mvp_run.gd 中实现 test_battle_complete_flow()：(1) 进入 MapScreen，点击第 1 个可点击节点进入 BattleScreen；(2) 验证 BattleScreen 初始化：玩家/敌人 HP、初始手牌、敌人意图显示正确；(3) 模拟玩家操作：从手牌选择 1 张攻击卡→点击敌人→验证敌人 HP 下降、手牌从 Hand 移至 Discard；(4) 模拟点击 '结束回合'→验证敌方回合执行（敌人放大招、玩家 HP 下降或扣 Block）；(5) 重复出牌直到敌人全灭→验证 core.battle.ended 事件触发、RewardPanel 打开；(6) 在 RewardPanel 选择卡牌奖励→验证牌组成功新增卡牌。输出：test_battle_complete_flow() 通过，战斗系统与奖励系统正常运作。",
            "status": "pending",
            "testStrategy": "GdUnit4：模拟多轮出牌与敌方 AI 交互；验证 HP 值变化、手牌移动、事件发布、奖励界面正确打开；使用固定敌人与确定性 RNG"
          },
          {
            "id": "4",
            "title": "实现地图进度与 Boss 战流程测试（奖励→Boss→结算）",
            "description": "测试玩家选择奖励后回到地图、节点标记完成、下一层解锁、逐层推进直到 Boss 节点、Boss 战胜利后显示结算界面。",
            "dependencies": [
              "3"
            ],
            "details": "在 test_mvp_run.gd 中实现 test_map_progression_and_boss()：(1) 奖励选择完成后，验证回到 MapScreen；(2) 验证刚完成的节点状态变为 Completed（显示勾、禁用点击），下一层第 1 个节点变为 Accessible；(3) 循环执行 3-4 次完整战斗流程，每次确认节点推进、牌组增长；(4) 当到达 Boss 层时，验证该节点为 Boss 类型；(5) 模拟 Boss 战斗与胜利→验证 core.battle.ended 触发、Boss 战胜利后直接进入 RunEndScreen（而非 RewardPanel）；(6) 在 RunEndScreen 验证：显示最终统计（累积伤害、卡牌数量、运行时间）、'重新开始' 按钮可点击。输出：完整单局游戏闭环通过，从开局到结算。",
            "status": "pending",
            "testStrategy": "GdUnit4：验证地图节点状态转换序列、多轮战斗稳定性、Boss 节点特殊处理、结算界面正确渲染；检查无死循环、无状态不一致"
          },
          {
            "id": "5",
            "title": "实现重新开始与手动冒烟测试清单",
            "description": "测试点击 '重新开始' 按钮后完整重置、生成新地图、重新开局的流程，并编写 QA 手动冒烟测试清单文档。",
            "dependencies": [
              "4"
            ],
            "details": "在 test_mvp_run.gd 中实现 test_restart_flow()：(1) 从 RunEndScreen 点击 '重新开始' 按钮；(2) 验证场景转换回 MapScreen；(3) 验证新地图生成：所有节点状态重置为初始（仅第 1 层可访问），节点 ID/类型与上一局完全不同（不同随机种子），牌组重置为初始卡组；(4) 验证可进行第二局游戏。同时，在 docs/testing/mvp-smoke-test.md 中编写手动冒烟清单，覆盖：开局→3-4 个节点战斗→Boss 战→结算→重开，包含验收标准（无崩溃、无卡死、所有节点可点击、敌人 AI 正常、奖励可选择）。输出：test_restart_flow() 通过、mvp-smoke-test.md 完整，供 QA 手动验证。",
            "status": "pending",
            "testStrategy": "GdUnit4 自动化 + 手动清单：验证地图完全重置、RNG 产生不同结果、可连续进行多局游戏；手动清单包含约 20 分钟的可玩验证路径"
          }
        ],
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 编写 E2E 可玩闭环冒烟测试.",
        "updatedAt": null
      },
      {
        "id": "30",
        "title": "性能与质量门禁验证",
        "description": "验证 T2 阶段性能指标与覆盖率门禁达标",
        "details": "运行质量门禁脚本 scripts/python/quality_gates.py:\n- 覆盖率门禁:\n  - 核心逻辑(Game.Core)覆盖率 ≥90% lines, ≥85% branches\n  - 运行 dotnet test --collect:\"XPlat Code Coverage\" 收集覆盖率\n- 性能烟测:\n  - 启动时间 ≤3s\n  - 战斗逻辑帧耗时 P95 ≤16.6ms(60fps)\n  - 运行 scripts/python/perf_smoke.py 采样性能数据\n- 安全烟测:\n  - 验证仅允许 res:// 与 user:// 路径读写\n  - 运行 scripts/python/scan_godot_security.py 扫描不安全 API\n- 产出日志:\n  - logs/unit/coverage.json\n  - logs/perf/summary.json\n  - logs/ci/security-audit.jsonl\n通过标准: 所有门禁绿灯,无阻塞问题。\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "CI 工作流:\n- dotnet-unit 作业: 运行单元测试并收集覆盖率\n- godot-e2e 作业: headless 运行冒烟测试与性能采样\n- 安全审计: 扫描脚本输出 JSONL\n本地验证: 运行 py -3 scripts/python/quality_gates.py --all 验证所有门禁",
        "priority": "medium",
        "dependencies": [
          "29"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": "1",
            "title": "配置 GitHub Actions CI/CD 工作流文件",
            "description": "创建 .github/workflows/ 目录并编写主工作流文件 quality-gates.yml，定义作业触发条件、环境变量与作业序列",
            "dependencies": [],
            "details": "创建 .github/workflows/quality-gates.yml 文件，包含：\n1. 触发条件：push 到 main/develop、pull_request\n2. 环境变量：GODOT_BIN、GODOT_PROJECT、CI=true\n3. 作业顺序：dotnet-typecheck-lint → dotnet-unit → godot-e2e → task-links-validate → release-health → package\n4. 使用 Windows-latest runner\n5. 配置 .NET 8 SDK 与 Python 3.11\n6. 缓存策略：NuGet、Godot export templates",
            "status": "pending",
            "testStrategy": "验证工作流文件语法正确（github actions lint），手动测试：push 触发工作流运行，检查作业是否按序执行"
          },
          {
            "id": "2",
            "title": "集成 dotnet 编译、类型检查与 linting 作业",
            "description": "实现 dotnet-typecheck-lint 作业，验证代码编译无误、类型检查通过、代码风格符合规范",
            "dependencies": [
              "1"
            ],
            "details": "创建 dotnet-typecheck-lint 作业配置：\n1. 恢复依赖：dotnet restore\n2. 类型检查与编译：dotnet build -warnaserror（将警告视为错误）\n3. 代码格式验证：dotnet format analyzers --verify-no-changes（可选）\n4. 日志输出：将 typecheck.log、lint.log 保存到 logs/ci/<YYYY-MM-DD>/\n5. 失败时：上传日志作为工件，阻止后续作业运行\n6. 输出标准：未捕获异常数为 0，所有代码路径类型安全",
            "status": "pending",
            "testStrategy": "xUnit 单元测试：验证编译时警告捕获；集成测试：intentionally introduce warning 然后验证 -warnaserror 捕获；本地测试：dotnet build -warnaserror 通过"
          },
          {
            "id": "3",
            "title": "集成单元测试与覆盖率验证作业",
            "description": "实现 dotnet-unit 作业，运行 xUnit 单元测试并收集代码覆盖率，验证达到 Game.Core ≥90% lines、≥85% branches 的门禁标准",
            "dependencies": [
              "2"
            ],
            "details": "创建 dotnet-unit 作业配置：\n1. 运行测试：dotnet test --collect:\"XPlat Code Coverage\" --logger=json --results-directory=./TestResults\n2. 解析覆盖率：使用 coverlet 生成 coverage.json，解析 lines 与 branches 数据\n3. 验证覆盖率阈值：Game.Core ≥90% lines、≥85% branches；若不达标则作业失败\n4. 输出日志：logs/unit/<YYYY-MM-DD>/coverage.json、logs/unit/<YYYY-MM-DD>/junit.xml\n5. 失败条件：测试失败或覆盖率不达标\n6. 缓存策略：缓存 NuGet packages 加速后续运行",
            "status": "pending",
            "testStrategy": "集成测试：编写覆盖率不足的单元测试，验证门禁检查失败；编写足量测试达到阈值，验证门禁通过；本地验证：dotnet test --collect:\"XPlat Code Coverage\" 覆盖率输出"
          },
          {
            "id": "4",
            "title": "集成 E2E 与安全烟测作业",
            "description": "实现 godot-e2e 作业，在 headless 模式下运行 GdUnit4 场景测试、性能烟测与安全扫描，验证启动时间、帧耗时、权限隔离",
            "dependencies": [
              "2"
            ],
            "details": "创建 godot-e2e 作业配置：\n1. 环境设置：GD_SECURE_MODE=1、SECURITY_TEST_MODE=1、ALLOWED_EXTERNAL_HOSTS=<白名单>\n2. 场景冒烟测试：运行 GdUnit4 测试套件 tests/e2e/test_mvp_run.gd（或 godot 命令）\n3. 性能烟测：py -3 scripts/python/perf_smoke.py --scene res://scenes/Main.tscn --samples 30 --threshold 16.6（毫秒）\n4. 安全扫描：py -3 scripts/python/scan_godot_security.py --output logs/ci/<date>/security-audit.jsonl\n5. 日志输出：logs/e2e/<YYYY-MM-DD>/junit.xml、logs/perf/<YYYY-MM-DD>/summary.json、logs/ci/<YYYY-MM-DD>/security-audit.jsonl\n6. 通过标准：无崩溃、启动 ≤3s、P95 帧耗时 ≤16.6ms、安全扫描无高危项\n7. 失败条件：任何测试失败或性能/安全阈值超标",
            "status": "pending",
            "testStrategy": "GdUnit4 集成测试：test_mvp_run.gd 覆盖完整流程；性能烟测：启动计时、帧耗时采样；安全扫描：检查路径越界、不安全 API 使用；本地验证：py -3 scripts/python/godot_tests.py --headless --suite smoke,security,perf"
          },
          {
            "id": "5",
            "title": "配置分支保护规则与质量门禁阈值",
            "description": "在 GitHub 仓库设置中配置分支保护规则，确保 PR 必须通过所有质量门禁方可合并；配置环境变量覆盖机制以支持不同环境的阈值调整",
            "dependencies": [
              "3",
              "4"
            ],
            "details": "1. GitHub 分支保护配置（Settings → Branches → main）：\n   - 启用 \"Require status checks to pass before merging\"\n   - 必需检查：dotnet-typecheck-lint、dotnet-unit、godot-e2e、task-links-validate、release-health\n   - 启用 \"Require code reviews before merging\"（≥1 reviews）\n   - 启用 \"Dismiss stale pull request approvals when new commits are pushed\"\n2. 环境变量门禁配置（GitHub Secrets）：\n   - COVERAGE_LINES_MIN=90（Game.Core 代码行覆盖率最小值）\n   - COVERAGE_BRANCHES_MIN=85（Game.Core 分支覆盖率最小值）\n   - PERF_P95_THRESHOLD_MS=16.6（帧耗时 P95 阈值毫秒）\n   - PERF_STARTUP_THRESHOLD_S=3（启动时间阈值秒）\n   - RELEASE_CRASHFREE_THRESHOLD=99.5（发布健康 Crash-Free 阈值百分比）\n3. 本地开发环境变量配置（.env 模板）：\n   - 允许开发者覆盖阈值用于本地测试\n4. 文档更新（docs/quality-gates.md）：\n   - 记录所有门禁规则、阈值定义、通过标准、故障排除",
            "status": "pending",
            "testStrategy": "集成测试：创建测试 PR，验证未通过门禁时无法合并；创建通过门禁的 PR，验证可正常合并；本地验证：env 覆盖、py -3 scripts/python/quality_gates.py --all 通过"
          }
        ],
        "adrRefs": [
          "ADR-0005",
          "ADR-0006",
          "ADR-0011",
          "ADR-0015",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH05",
          "CH06",
          "CH07",
          "CH09",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 性能与质量门禁验证.",
        "updatedAt": null
      },
      {
        "id": "31",
        "title": "Headless smoke runner (Python) + strict mode",
        "description": "Implement a Python-first headless smoke runner for Godot on Windows, matching the existing PowerShell behavior. Add an optional strict mode that requires a success marker in logs.\n\nSource: docs/migration/Phase-12-Headless-Smoke-Backlog.md (B1/B2).",
        "status": "pending",
        "priority": "high",
        "dependencies": [],
        "details": "Story: PH12-BACKLOG-B1-B2\nADR Refs: ADR-0005; ADR-0011; ADR-0018; ADR-0024\nChapters: CH01; CH06; CH07; CH10\nTest Refs: logs/ci/<date>/smoke/headless.out.log; logs/ci/<date>/smoke/headless.err.log; logs/ci/<date>/smoke/summary.json\nAcceptance: Provide scripts/python/smoke_headless.py with --godot-bin, --scene, --timeout-sec, --project-path, and --strict.; Write outputs under logs/ci/<date>/smoke/** and return non-zero on strict failures.; Strict mode passes only if logs contain [TEMPLATE_SMOKE_READY] or [DB] opened.; Non-strict mode remains permissive to preserve template ergonomics.\nTest Strategy: Run locally on Windows against a known-good scene and verify exit code + artifacts.; Run in CI headless and confirm logs are archived under logs/ci/**.\nLabels: ci; smoke; godot; python; headless\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run locally on Windows against a known-good scene and verify exit code + artifacts.\nRun in CI headless and confirm logs are archived under logs/ci/**.",
        "adrRefs": [
          "ADR-0005",
          "ADR-0011",
          "ADR-0018",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Headless smoke runner (Python) + strict mode.",
        "updatedAt": null
      },
      {
        "id": "32",
        "title": "Integrate GdUnit4 suites into quality_gates.py",
        "description": "Extend scripts/python/quality_gates.py to optionally run selected GdUnit4 suites (adapters/security as hard gate, integration/UI as soft gate) and aggregate results into a single summary JSON.\n\nSource: docs/migration/Phase-13-Quality-Gates-Backlog.md (B2).",
        "status": "pending",
        "priority": "high",
        "dependencies": [
          "31"
        ],
        "details": "Story: PH13-BACKLOG-B2\nADR Refs: ADR-0005; ADR-0011; ADR-0024\nChapters: CH06; CH07; CH10\nTest Refs: logs/ci/<date>/quality-gates/summary.json; logs/e2e/<date>/gdunit/junit.xml\nAcceptance: quality_gates.py exposes flags to run GdUnit4 suites and includes them in the unified decision.; Adapters+Security suite is treated as hard gate; Integration/UI remains soft gate initially.; All outputs land under logs/ci/** and logs/e2e/** with a machine-readable summary.\nTest Strategy: Run quality_gates.py locally with and without GdUnit4 flags to verify behavior.; Validate CI job consumes the summary JSON for pass/fail decisions.\nLabels: ci; quality-gates; gdunit4; headless\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run quality_gates.py locally with and without GdUnit4 flags to verify behavior.\nValidate CI job consumes the summary JSON for pass/fail decisions.",
        "adrRefs": [
          "ADR-0005",
          "ADR-0011",
          "ADR-0024"
        ],
        "archRefs": [
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Integrate GdUnit4 suites into quality_gates.py.",
        "updatedAt": null
      },
      {
        "id": "33",
        "title": "Coverage thresholds as configurable soft/hard gate",
        "description": "Align xUnit coverage thresholds to the blueprint target (lines >= 90%, branches >= 85%) and allow overriding via environment variables. Provide soft/hard gate modes in scripts/python/run_dotnet.py and scripts/python/quality_gates.py.\n\nSource: docs/migration/Phase-13-Quality-Gates-Backlog.md (B1).",
        "status": "pending",
        "priority": "high",
        "dependencies": [
          "32"
        ],
        "details": "Story: PH13-BACKLOG-B1\nADR Refs: ADR-0005\nChapters: CH07\nTest Refs: logs/unit/<date>/summary.json; logs/ci/<date>/quality-gates/summary.json\nAcceptance: Default thresholds match the project standard (lines>=90, branches>=85) while remaining overrideable by env vars.; Soft gate records warnings; hard gate fails the pipeline with a non-zero exit code.; Coverage results are surfaced in a single summary JSON for CI consumption.\nTest Strategy: Run dotnet tests on Windows and verify threshold behavior by temporarily setting env vars.\nLabels: ci; coverage; xunit\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run dotnet tests on Windows and verify threshold behavior by temporarily setting env vars.",
        "adrRefs": [
          "ADR-0005"
        ],
        "archRefs": [
          "CH07"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Coverage thresholds as configurable soft/hard gate.",
        "updatedAt": null
      },
      {
        "id": "34",
        "title": "Audit JSONL validation + gate integration",
        "description": "Add a Python validator for security audit JSONL outputs and integrate it into the quality gates flow.\n\nSource: docs/migration/Phase-14-Godot-Security-Backlog.md (B4) and Phase-13 backlog (B4).",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          "32"
        ],
        "details": "Story: PH14-BACKLOG-B4\nADR Refs: ADR-0019; ADR-0003; ADR-0005\nChapters: CH02; CH03; CH07\nTest Refs: logs/ci/<date>/security-audit.jsonl; logs/ci/<date>/audit-validate/report.json\nAcceptance: Provide scripts/python/validate_audit_logs.py to validate JSONL structure and required fields.; quality_gates.py optionally calls the validator and records results in its summary JSON.; Validation failures are actionable and include offending line numbers and reasons.\nTest Strategy: Use a small fixture JSONL (valid and invalid) to verify pass/fail behavior.\nLabels: ci; security; audit; jsonl\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Use a small fixture JSONL (valid and invalid) to verify pass/fail behavior.",
        "adrRefs": [
          "ADR-0019",
          "ADR-0003",
          "ADR-0005"
        ],
        "archRefs": [
          "CH02",
          "CH03",
          "CH07"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Audit JSONL validation + gate integration.",
        "updatedAt": null
      },
      {
        "id": "35",
        "title": "External URL allowlist + safe ShellOpen adapter",
        "description": "Provide a single safe entry point for opening external URLs and enforce HTTPS + allowlisted hosts. Support GD_OFFLINE_MODE=1 to deny all network-like actions and write audit records.\n\nSource: docs/migration/Phase-14-Godot-Security-Backlog.md (B1).",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "details": "Story: PH14-BACKLOG-B1\nADR Refs: ADR-0019; ADR-0011; ADR-0018\nChapters: CH01; CH02; CH06; CH07; CH10\nTest Refs: Game.Core.Tests/Security/ExternalUrlPolicyTests.cs; logs/ci/<date>/security-audit.jsonl\nAcceptance: All OS.ShellOpen usage goes through a single adapter that enforces HTTPS + allowlist.; Allowed hosts are configured via ALLOWED_EXTERNAL_HOSTS (env/config) and audited on deny.; GD_OFFLINE_MODE=1 denies all external URL opens and records an audit entry.\nTest Strategy: xUnit tests cover allow/deny/invalid URL cases and offline mode behavior.\nLabels: security; url; allowlist; offline-mode\nOwner: architecture\nLayer: adapter\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Allowed-External-Hosts.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit tests cover allow/deny/invalid URL cases and offline mode behavior.",
        "adrRefs": [
          "ADR-0019",
          "ADR-0011",
          "ADR-0018"
        ],
        "archRefs": [
          "CH01",
          "CH02",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on External URL allowlist + safe ShellOpen adapter.",
        "updatedAt": null
      },
      {
        "id": "36",
        "title": "Secure file access adapter (res:// read-only, user:// read-write)",
        "description": "Introduce a file access adapter that enforces the allowed roots (res://, user://), rejects absolute paths and path traversal, and emits audit records on violations.\n\nSource: docs/migration/Phase-14-Godot-Security-Backlog.md (B2).",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "details": "Story: PH14-BACKLOG-B2\nADR Refs: ADR-0019; ADR-0006; ADR-0011\nChapters: CH02; CH05; CH07; CH10\nTest Refs: Game.Core.Tests/Security/FilePolicyTests.cs; logs/ci/<date>/security-audit.jsonl\nAcceptance: Provide a single adapter for FileAccess/DirAccess that enforces res:// and user:// rules.; Reject absolute paths and ../ traversal across all entry points.; Denied accesses write an audit JSONL record with reason + target.\nTest Strategy: xUnit tests cover user:// allow, res:// allow-read-only, absolute path deny, and traversal deny.\nLabels: security; filesystem; adapter\nOwner: architecture\nLayer: adapter\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit tests cover user:// allow, res:// allow-read-only, absolute path deny, and traversal deny.",
        "adrRefs": [
          "ADR-0019",
          "ADR-0006",
          "ADR-0011"
        ],
        "archRefs": [
          "CH02",
          "CH05",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Secure file access adapter (res:// read-only, user:// read-write).",
        "updatedAt": null
      },
      {
        "id": "37",
        "title": "Performance budget gate integrated into quality gates",
        "description": "Ensure performance P95 budget checks are consistently executed in CI and surfaced in the unified quality gates summary.\n\nSource: docs/migration/Phase-15-Performance-Budgets-Backlog.md (B1) and ADR-0015.",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          "32"
        ],
        "details": "Story: PH15-BACKLOG-B1\nADR Refs: ADR-0015; ADR-0005\nChapters: CH07; CH09\nTest Refs: logs/perf/<date>/summary.json; logs/ci/<date>/quality-gates/summary.json\nAcceptance: Perf P95 budget check runs in CI (headless) and writes logs/perf/<date>/summary.json.; quality_gates.py consumes the perf summary and records pass/fail (soft/hard mode configurable).\nTest Strategy: Run perf suite locally with a low threshold to force a failure and verify gate behavior.\nLabels: perf; ci; budget; p95\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run perf suite locally with a low threshold to force a failure and verify gate behavior.",
        "adrRefs": [
          "ADR-0015",
          "ADR-0005"
        ],
        "archRefs": [
          "CH07",
          "CH09"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Performance budget gate integrated into quality gates.",
        "updatedAt": null
      },
      {
        "id": "38",
        "title": "Baseline-based performance regression comparison (optional)",
        "description": "Add an optional baseline comparison workflow that compares current perf metrics against stored baseline JSON and fails if deviation exceeds tolerance.\n\nSource: docs/migration/Phase-15-Performance-Budgets-Backlog.md (B2).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "37"
        ],
        "details": "Story: PH15-BACKLOG-B2\nADR Refs: ADR-0015; ADR-0005\nChapters: CH07; CH09\nTest Refs: benchmarks/*.json; logs/perf/<date>/comparison.json\nAcceptance: Provide scripts/python/performance_gates.py to compare baseline vs current and output a diff JSON.; Support tolerance percentage to avoid noise-driven failures.\nTest Strategy: Use a small fixture baseline/current JSON pair to validate compare logic.\nLabels: perf; baseline; ci\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Use a small fixture baseline/current JSON pair to validate compare logic.",
        "adrRefs": [
          "ADR-0015",
          "ADR-0005"
        ],
        "archRefs": [
          "CH07",
          "CH09"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Baseline-based performance regression comparison (optional).",
        "updatedAt": null
      },
      {
        "id": "39",
        "title": "Observability bootstrap (structured logs + optional Sentry init)",
        "description": "Implement an observability bootstrap in Godot (autoload) to provide structured logs and (optionally) initialize Sentry SDK when configured.\n\nSource: docs/migration/Phase-16-Observability-Backlog.md (B1).",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "details": "Story: PH16-BACKLOG-B1\nADR Refs: ADR-0003; ADR-0018; ADR-0011\nChapters: CH01; CH03; CH06; CH07; CH10\nTest Refs: logs/ci/<date>/observability/selfcheck.json\nAcceptance: Provide an early-init entry point that is executed before the main scene is loaded.; Structured logs include consistent fields (ts, level, logger, message, tags/extra) and write to logs/**.; Sentry init is controlled by config/env vars and never hardcodes secrets.\nTest Strategy: Run headless selfcheck and verify structured log output is produced.\nLabels: observability; logging; sentry\nOwner: architecture\nLayer: adapter\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run headless selfcheck and verify structured log output is produced.",
        "adrRefs": [
          "ADR-0003",
          "ADR-0018",
          "ADR-0011"
        ],
        "archRefs": [
          "CH01",
          "CH03",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Observability bootstrap (structured logs + optional Sentry init).",
        "updatedAt": null
      },
      {
        "id": "40",
        "title": "Release health gate script (Sentry Sessions) + CI integration",
        "description": "Provide a Windows-friendly release health gate script that queries Sentry Sessions/Users and enforces the Crash-Free threshold defined in ADR-0003.\n\nSource: docs/migration/Phase-16-Observability-Backlog.md (B3) and Phase-19 backlog (B1).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "39"
        ],
        "details": "Story: PH16-BACKLOG-B3\nADR Refs: ADR-0003; ADR-0005; ADR-0011; ADR-0008\nChapters: CH03; CH07; CH10\nTest Refs: logs/ci/<date>/release-health.json\nAcceptance: Provide scripts/python/release_health_gate.py that writes logs/ci/<date>/release-health.json.; CI can enable/disable this step via environment variables and does not require code changes.; No secrets are checked into git; scripts validate required env vars and fail fast with context.\nTest Strategy: Run in dry-run mode with stub data (or missing env vars) and verify failure is explicit and logged.\nLabels: release-health; sentry; ci\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run in dry-run mode with stub data (or missing env vars) and verify failure is explicit and logged.",
        "adrRefs": [
          "ADR-0003",
          "ADR-0005",
          "ADR-0011",
          "ADR-0008"
        ],
        "archRefs": [
          "CH03",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down this task with a focus on Release health gate script (Sentry Sessions) + CI integration.",
        "updatedAt": null,
        "subtasks": [
          {
            "id": "1",
            "title": "Define release-health JSON schema and configuration surface",
            "description": "Define the release health gate inputs/outputs (env vars, thresholds, and JSON schema) for release_health_gate.py.",
            "dependencies": [],
            "details": "Define required env vars and defaults:\n- SENTRY_AUTH_TOKEN / SENTRY_ORG / SENTRY_PROJECT / SENTRY_ENV\n- RELEASE_CRASHFREE_THRESHOLD (default aligned to ADR-0003)\n- RELEASE_HEALTH_WINDOW_HOURS (default 24)\n- RELEASE_HEALTH_MODE=skip|warn|require (default require in release workflows; warn/skip in PR if desired)\nDefine output path and minimal schema:\n- logs/ci/<YYYY-MM-DD>/release-health.json\n- Fields: ts, mode, window_hours, threshold, crashfree_sessions, crashfree_users, status, reason, project, env\nSecurity: never print tokens; log only which env vars are missing.",
            "status": "pending",
            "testStrategy": "Run with missing env vars and verify the failure is explicit (mode=require) and written to logs/ci/**."
          },
          {
            "id": "2",
            "title": "Implement Sentry Sessions query (Crash-Free Sessions/Users)",
            "description": "Implement Sentry API calls and parsing to compute Crash-Free Sessions/Users over a rolling window.",
            "dependencies": [
              "1"
            ],
            "details": "Implement scripts/python/release_health_gate.py:\n- Query Sentry metrics for crash-free sessions/users over window_hours\n- Handle timeouts/rate limits gracefully; fail fast with context\n- Support a --dry-run / stub mode to run without network in CI smoke\nKeep logic deterministic for unit tests (use stub JSON fixtures).",
            "status": "pending",
            "testStrategy": "Add deterministic unit tests using stub responses to validate parsing and computed crash-free rates."
          },
          {
            "id": "3",
            "title": "Implement gate decision + evidence logging",
            "description": "Compare crash-free rates with threshold, write evidence JSON, and return correct exit code per mode.",
            "dependencies": [
              "2"
            ],
            "details": "Gate behavior:\n- mode=require: rc!=0 on below threshold or API errors\n- mode=warn: always rc=0 but status=fail in JSON when below threshold\n- mode=skip: write a skipped JSON record (optional) and rc=0\nAlways write logs/ci/<date>/release-health.json with status + reason.",
            "status": "pending",
            "testStrategy": "Run dry-run for both pass/fail cases and verify JSON fields + exit codes match mode semantics."
          },
          {
            "id": "4",
            "title": "Integrate into GitHub Actions workflows",
            "description": "Wire the release-health gate into Windows workflows with toggles and artifact upload.",
            "dependencies": [
              "3"
            ],
            "details": "Update workflows:\n- windows-quality-gate.yml: optional (warn/skip) mode\n- windows-release*.yml: require mode\nEnsure logs/ci/** includes release-health.json and is uploaded as artifact.\nSecrets must be provided via GitHub Secrets; do not commit any tokens.",
            "status": "pending",
            "testStrategy": "In CI, verify the step can be toggled on/off via env vars and artifacts include release-health.json."
          }
        ]
      },
      {
        "id": "41",
        "title": "Build/export pipeline hardening (Windows-only)",
        "description": "Harden the Windows build/export pipeline: environment checks, consistent artifacts, and log outputs under logs/ci/**.\n\nSource: docs/migration/Phase-17-Build-Backlog.md (B1/B2).",
        "status": "pending",
        "priority": "medium",
        "dependencies": [],
        "details": "Story: PH17-BACKLOG-B1-B2\nADR Refs: ADR-0018; ADR-0005; ADR-0011; ADR-0008\nChapters: CH01; CH06; CH07; CH10\nTest Refs: logs/ci/<date>/export/export.log; logs/ci/<date>/export/summary.json\nAcceptance: Export step produces deterministic artifact names and a machine-readable summary JSON.; Failures surface as non-zero exit codes and logs include environment diagnostics.\nTest Strategy: Run export in a local Windows environment and confirm build artifacts + logs are generated.\nLabels: build; export; windows; ci\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run export in a local Windows environment and confirm build artifacts + logs are generated.",
        "adrRefs": [
          "ADR-0018",
          "ADR-0005",
          "ADR-0011",
          "ADR-0008"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Build/export pipeline hardening (Windows-only).",
        "updatedAt": null
      },
      {
        "id": "42",
        "title": "Release channel + release profile metadata (optional)",
        "description": "Introduce a release channel concept (qa/internal/beta/stable) and generate a release profile JSON capturing channel + enabled FeatureFlags + build metadata for traceability.\n\nSource: docs/migration/Phase-18-Staged-Release-Backlog.md (B1/B2).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "details": "Story: PH18-BACKLOG-B1-B2\nADR Refs: ADR-0003; ADR-0008; ADR-0005\nChapters: CH03; CH07; CH10\nTest Refs: build/release-profile.json\nAcceptance: Release profile JSON includes version, commit, channel, enabled flags, built_at, and CI run id when available.; Release notes generation can reference the profile to display channel/flags.\nTest Strategy: Run build/export with RELEASE_CHANNEL set and verify release-profile.json contents.\nLabels: release; canary; feature-flags\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run build/export with RELEASE_CHANNEL set and verify release-profile.json contents.",
        "adrRefs": [
          "ADR-0003",
          "ADR-0008",
          "ADR-0005"
        ],
        "archRefs": [
          "CH03",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Release channel + release profile metadata (optional).",
        "updatedAt": null
      },
      {
        "id": "43",
        "title": "Privacy & logging guidelines docs (project-facing)",
        "description": "Create project-facing privacy and logging guidelines documents to consolidate existing scattered rules and reduce future ambiguity.\n\nSource: docs/migration/Phase-16-Observability-Backlog.md (B4/B5).",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "details": "Story: PH16-BACKLOG-B4-B5\nADR Refs: ADR-0003; ADR-0019\nChapters: CH02; CH03\nAcceptance: docs/privacy-compliance.md exists and defines allowed/forbidden data in logs and telemetry.; docs/logging-guidelines.md exists and aligns with the logs/** SSoT directory structure.\nTest Strategy: Doc review: ensure ADR references are correct and no secrets/PII examples are included.\nLabels: docs; privacy; logging\nOwner: architecture\nLayer: docs\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Doc review: ensure ADR references are correct and no secrets/PII examples are included.",
        "adrRefs": [
          "ADR-0003",
          "ADR-0019"
        ],
        "archRefs": [
          "CH02",
          "CH03"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Privacy & logging guidelines docs (project-facing).",
        "updatedAt": null
      },
      {
        "id": "44",
        "title": "Duplication and cyclomatic complexity gate (lightweight)",
        "description": "Add lightweight duplication and cyclomatic complexity checks suitable for a Windows-only Godot+C# repo. Prefer Roslyn analyzers / dotnet tooling and small Python scanners over heavy external platforms.\n\nSource: docs/migration/Phase-13-Quality-Gates-Backlog.md (B3).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "32"
        ],
        "details": "Story: PH13-BACKLOG-B3\nADR Refs: ADR-0005; ADR-0011\nChapters: CH07; CH10\nTest Refs: logs/ci/<date>/quality-gates/duplication.json; logs/ci/<date>/quality-gates/complexity.json\nAcceptance: quality_gates.py can run duplication/complexity checks and records results in a summary JSON.; Checks have configurable thresholds and default to soft gate for T2 (upgradeable to hard gate later).; Artifacts are written under logs/ci/** for troubleshooting and archiving.\nTest Strategy: Run quality_gates.py locally on Windows and confirm reports are generated and parsed.\nLabels: ci; quality-gates; duplication; complexity\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run quality_gates.py locally on Windows and confirm reports are generated and parsed.",
        "adrRefs": [
          "ADR-0005",
          "ADR-0011"
        ],
        "archRefs": [
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Duplication and cyclomatic complexity gate (lightweight).",
        "updatedAt": null
      },
      {
        "id": "45",
        "title": "Architecture tests (Core must not depend on Godot)",
        "description": "Add xUnit-based architecture tests to enforce the three-layer boundary: Game.Core must not reference Godot APIs, and adapters are the only layer allowed to touch Godot.\n\nSource: docs/migration/Phase-13-Quality-Gates-Backlog.md (B5).",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          "32"
        ],
        "details": "Story: PH13-BACKLOG-B5\nADR Refs: ADR-0007; ADR-0005; ADR-0024; ADR-0018\nChapters: CH01; CH05; CH06; CH07\nTest Refs: Game.Core.Tests/Architecture/LayerDependencyTests.cs\nAcceptance: dotnet test fails if Game.Core references Godot types/namespaces.; Rules are explicit and documented in the test file for maintainability.\nTest Strategy: Introduce a small intentional violation in a temp branch to verify the test catches it.\nLabels: ci; architecture-tests; ports-adapters\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Introduce a small intentional violation in a temp branch to verify the test catches it.",
        "adrRefs": [
          "ADR-0007",
          "ADR-0005",
          "ADR-0024",
          "ADR-0018"
        ],
        "archRefs": [
          "CH01",
          "CH05",
          "CH06",
          "CH07"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Architecture tests (Core must not depend on Godot).",
        "updatedAt": null
      },
      {
        "id": "46",
        "title": "OS.execute guard (deny-by-default) + audit",
        "description": "Provide a single adapter for external process execution and keep OS.execute disabled by default. Allow only explicit dev-mode allowlisted commands and write audit records on any deny/allow.\n\nSource: docs/migration/Phase-14-Godot-Security-Backlog.md (B3).",
        "status": "pending",
        "priority": "low",
        "dependencies": [],
        "details": "Story: PH14-BACKLOG-B3\nADR Refs: ADR-0019; ADR-0011; ADR-0005\nChapters: CH02; CH07; CH10\nTest Refs: Game.Core.Tests/Security/ProcessPolicyTests.cs; logs/ci/<date>/security-audit.jsonl\nAcceptance: No direct OS.execute calls remain in product code; use the guard adapter instead.; Default behavior is deny with an audit JSONL record.; A development-only allowlist path exists but is off by default (GD_SECURE_MODE=1).\nTest Strategy: xUnit tests cover deny-by-default and allowlist behavior with SECURITY_TEST_MODE=1.\nLabels: security; process; audit\nOwner: architecture\nLayer: adapter\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "xUnit tests cover deny-by-default and allowlist behavior with SECURITY_TEST_MODE=1.",
        "adrRefs": [
          "ADR-0019",
          "ADR-0011",
          "ADR-0005"
        ],
        "archRefs": [
          "CH02",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on OS.execute guard (deny-by-default) + audit.",
        "updatedAt": null
      },
      {
        "id": "47",
        "title": "Signal contract validation and tests (security-sensitive)",
        "description": "Add contract validation for security-sensitive signals (naming/arguments) and integrate into CI checks. This should catch accidental drift between signal definitions and expected contracts.\n\nSource: docs/migration/Phase-14-Godot-Security-Backlog.md (B5).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "35",
          "36"
        ],
        "details": "Story: PH14-BACKLOG-B5\nADR Refs: ADR-0004; ADR-0019; ADR-0005\nChapters: CH02; CH04; CH07\nTest Refs: Tests.Godot/tests/Security/test_signal_contracts.gd; logs/e2e/<date>/security/signal-contracts.json\nAcceptance: Contract checks validate that required security-related signals exist and match expected parameter shapes.; Headless test suite produces a machine-readable report under logs/e2e/**.\nTest Strategy: Run headless GdUnit4 suite and confirm contract checks report PASS/FAIL deterministically.\nLabels: ci; signals; contracts; security\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-CloudEvent.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-CloudEvents-Core.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run headless GdUnit4 suite and confirm contract checks report PASS/FAIL deterministically.",
        "adrRefs": [
          "ADR-0004",
          "ADR-0019",
          "ADR-0005"
        ],
        "archRefs": [
          "CH02",
          "CH04",
          "CH07"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Signal contract validation and tests (security-sensitive).",
        "updatedAt": null
      },
      {
        "id": "48",
        "title": "Performance reports and history artifacts (project-level)",
        "description": "Generate a human-readable performance report and keep a minimal history artifact (CSV/JSONL) for trend tracking. This is optional for T2 but should be ready before any wider distribution.\n\nSource: docs/migration/Phase-15-Performance-Budgets-Backlog.md (B3).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "37"
        ],
        "details": "Story: PH15-BACKLOG-B3\nADR Refs: ADR-0015; ADR-0005\nChapters: CH07; CH09\nTest Refs: logs/perf/<date>/summary.json; logs/perf/<date>/report.json\nAcceptance: Perf runs emit both summary.json and an extended report.json (or equivalent) under logs/perf/**.; A minimal history artifact is produced without committing logs/ to git.\nTest Strategy: Run perf suite locally and inspect the generated report files for completeness.\nLabels: perf; report; ci\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run perf suite locally and inspect the generated report files for completeness.",
        "adrRefs": [
          "ADR-0015",
          "ADR-0005"
        ],
        "archRefs": [
          "CH07",
          "CH09"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Performance reports and history artifacts (project-level).",
        "updatedAt": null
      },
      {
        "id": "49",
        "title": "Dedicated performance gate workflow (optional)",
        "description": "Add a dedicated CI workflow/job that runs only the performance gate (headless) and uploads perf artifacts.\n\nSource: docs/migration/Phase-15-Performance-Budgets-Backlog.md (B5).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "37"
        ],
        "details": "Story: PH15-BACKLOG-B5\nADR Refs: ADR-0015; ADR-0005; ADR-0011\nChapters: CH07; CH09; CH10\nTest Refs: logs/perf/<date>/summary.json\nAcceptance: CI can run a perf-only job that fails on budget violations (configurable soft/hard).; Perf artifacts are uploaded as CI artifacts for later analysis.\nTest Strategy: Trigger the workflow manually and verify artifact upload and pass/fail behavior.\nLabels: perf; ci; workflow\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Trigger the workflow manually and verify artifact upload and pass/fail behavior.",
        "adrRefs": [
          "ADR-0015",
          "ADR-0005",
          "ADR-0011"
        ],
        "archRefs": [
          "CH07",
          "CH09",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Dedicated performance gate workflow (optional).",
        "updatedAt": null
      },
      {
        "id": "50",
        "title": "Game.Core observability client (structured logs + PII scrubbing)",
        "description": "Implement a pure C# observability client for Game.Core: structured logs, breadcrumbs, and optional sinks (e.g., Sentry via adapter). Include PII scrubbing rules aligned with ADR-0003/ADR-0019.\n\nSource: docs/migration/Phase-16-Observability-Backlog.md (B2).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "39"
        ],
        "details": "Story: PH16-BACKLOG-B2\nADR Refs: ADR-0003; ADR-0019; ADR-0005\nChapters: CH02; CH03; CH07\nTest Refs: Game.Core.Tests/Observability/StructuredLoggerTests.cs\nAcceptance: Game.Core can emit structured log events without referencing Godot APIs.; PII scrubbing is applied consistently and is covered by unit tests.\nTest Strategy: Unit tests validate field scrubbing, tag propagation, and sink invocation ordering.\nLabels: observability; logging; pii; core\nOwner: architecture\nLayer: core\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Unit tests validate field scrubbing, tag propagation, and sink invocation ordering.",
        "adrRefs": [
          "ADR-0003",
          "ADR-0019",
          "ADR-0005"
        ],
        "archRefs": [
          "CH02",
          "CH03",
          "CH07"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Game.Core observability client (structured logs + PII scrubbing).",
        "updatedAt": null
      },
      {
        "id": "51",
        "title": "Dedicated Windows release workflow (tag/dispatch) + artifacts",
        "description": "Provide a dedicated GitHub Actions workflow for Windows releases (tag push or workflow_dispatch). It should export the game, run smoke, and upload artifacts with consistent naming.\n\nSource: docs/migration/Phase-17-Build-Backlog.md (B3).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "details": "Story: PH17-BACKLOG-B3\nADR Refs: ADR-0008; ADR-0011; ADR-0018; ADR-0005\nChapters: CH01; CH06; CH07; CH10\nTest Refs: logs/ci/<date>/export/summary.json\nAcceptance: Workflow triggers on tag or manual dispatch and uploads build artifacts.; Workflow includes smoke verification and attaches logs/ci artifacts for traceability.\nTest Strategy: Dry-run on a non-protected branch using workflow_dispatch and inspect uploaded artifacts.\nLabels: release; ci; export; windows\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Dry-run on a non-protected branch using workflow_dispatch and inspect uploaded artifacts.",
        "adrRefs": [
          "ADR-0008",
          "ADR-0011",
          "ADR-0018",
          "ADR-0005"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Dedicated Windows release workflow (tag/dispatch) + artifacts.",
        "updatedAt": null
      },
      {
        "id": "52",
        "title": "Optional code signing step (SignTool) for release artifacts",
        "description": "Add an optional code signing step using Windows SignTool, controlled by environment variables and secrets. No signing material is stored in git.\n\nSource: docs/migration/Phase-17-Build-Backlog.md (B4).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "51"
        ],
        "details": "Story: PH17-BACKLOG-B4\nADR Refs: ADR-0008; ADR-0011; ADR-0018\nChapters: CH01; CH06; CH07; CH10\nTest Refs: logs/ci/<date>/export/signing.log\nAcceptance: Signing runs only when required env vars are set; otherwise the step is skipped with a clear message.; Signing status is recorded in export summary/logs.\nTest Strategy: Run in a local environment without secrets to confirm it safely skips.\nLabels: release; signing; windows\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run in a local environment without secrets to confirm it safely skips.",
        "adrRefs": [
          "ADR-0008",
          "ADR-0011",
          "ADR-0018"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Optional code signing step (SignTool) for release artifacts.",
        "updatedAt": null
      },
      {
        "id": "53",
        "title": "Export presets for multiple configurations (debug/release/demo)",
        "description": "Define multiple export presets (Debug/Release/Demo) and update scripts to select presets via parameters.\n\nSource: docs/migration/Phase-17-Build-Backlog.md (B5).",
        "status": "pending",
        "priority": "low",
        "dependencies": [
          "41"
        ],
        "details": "Story: PH17-BACKLOG-B5\nADR Refs: ADR-0018; ADR-0011; ADR-0008\nChapters: CH01; CH06; CH07; CH10\nTest Refs: export_presets.cfg; logs/ci/<date>/export/summary.json\nAcceptance: At least two presets exist and can be selected from CI/local scripts.; Export summary includes which preset was used and the resulting artifact paths.\nTest Strategy: Run export for each preset and verify artifacts are produced and runnable.\nLabels: export; presets; ci\nOwner: architecture\nLayer: ci\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "testStrategy": "Run export for each preset and verify artifacts are produced and runnable.",
        "adrRefs": [
          "ADR-0018",
          "ADR-0011",
          "ADR-0008"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md",
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on Export presets for multiple configurations (debug/release/demo).",
        "updatedAt": null
      },
      {
        "id": "54",
        "title": "实现卡牌交互基础组件 (CardView/HandLayout/HoverPreview)",
        "description": "实现可复用的卡牌 UI 基础组件，为 Battle/Reward/Shop/Rest 共用（参考 demo/godot-card-game-framework 与 demo/Godot-CardPileFramework 的交互模式）。",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          "1",
          "2"
        ],
        "details": "Test Refs: Tests.Godot/tests/UI/test_card_view_scene.gd\nAcceptance: Provide reusable CardView + HandLayout components and keep gameplay rules in Game.Core.; Hover preview works in both mouse and keyboard focus navigation scenarios.; Add at least one headless GdUnit4 UI test (see test_refs) and produce artifacts under logs/e2e/**.\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "GdUnit4 UI 测试（headless）覆盖 CardView 实例化与预览交互；手动冒烟验证 Battle/Reward/Shop/Rest 场景能复用组件。",
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 6,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on 实现卡牌交互基础组件 (CardView/HandLayout/HoverPreview).",
        "updatedAt": null
      },
      {
        "id": "55",
        "title": "实现出牌交互与目标选择 UX (Click/Targeting)",
        "description": "实现战斗中“选择卡牌 → 选择目标 → 确认出牌”的输入闭环，并与 BattleManager.PlayCard(heroId, cardId, targetId) 对齐（参考 demo/godot-card-game-framework 的 targeting 交互）。",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          "7",
          "20",
          "54"
        ],
        "details": "Test Refs: Tests.Godot/tests/Integration/test_battle_card_input_flow.gd\nAcceptance: BattleScreen supports click-to-select and target selection based on TargetRule; cancel path is supported.; Invalid plays (no energy / invalid target) do not mutate battle state and show a clear reason.; Add at least one headless GdUnit4 integration test (see test_refs) that covers a full play+cancel+invalid attempt flow.\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "GdUnit4 集成测试覆盖：有效出牌、取消出牌、能量不足与非法目标的失败路径。",
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 7,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down this task with a focus on 实现出牌交互与目标选择 UX (Click/Targeting).",
        "updatedAt": null,
        "subtasks": [
          {
            "id": "1",
            "title": "设计出牌交互状态机与数据绑定",
            "description": "在 BattleScreen 中定义“Idle → CardSelected → Targeting → Confirm/Cancel”的交互状态机，明确状态数据与 UI 绑定方式。",
            "dependencies": [],
            "details": "定义状态与转移：\n- Idle: 未选中卡\n- CardSelected: 已选中一张卡（显示预览/可选目标）\n- Targeting: 正在选择目标（按 TargetRule 限定）\n- Confirm: 目标已选定，等待确认出牌（或直接出牌）\n约束：只在 UI 层处理输入与高亮；不要在 UI 里复制 Game.Core 的规则计算。",
            "status": "pending",
            "testStrategy": "GdUnit4：验证状态机的关键转移（选卡→选目标→取消→回到 Idle）可重复且无残留 UI 状态。"
          },
          {
            "id": "2",
            "title": "实现目标高亮/指示与选择交互",
            "description": "实现合法目标高亮（单位/格子/敌人），并提供明确的目标指示（例如箭头/连线/光圈）。",
            "dependencies": [
              "1"
            ],
            "details": "根据 CardDefinition.TargetRule 计算合法目标集合：\n- SingleEnemy/AllEnemies/SingleAlly/AllAllies/Random\n交互要求：\n- hover/click 可选择目标\n- 非法目标点击不会进入确认态，并给出原因提示\n实现参考（概念级）：demo/godot-card-game-framework 的 targeting 交互（不要直接复制 Godot3 代码）。",
            "status": "pending",
            "testStrategy": "GdUnit4：选卡后合法目标被高亮；点击非法目标不改变 BattleManager 状态。"
          },
          {
            "id": "3",
            "title": "实现取消/回退路径与输入一致性",
            "description": "实现取消路径（ESC/右键/空白点击等），并保证所有 UI 状态（高亮/箭头/预览）可完全回收。",
            "dependencies": [
              "1",
              "2"
            ],
            "details": "取消要求：\n- CardSelected/Targeting 任意阶段都可取消并回到 Idle\n- 取消后不保留任何目标高亮/指示节点\n- 取消不改变 Game.Core 战斗状态",
            "status": "pending",
            "testStrategy": "GdUnit4：覆盖“选卡→选目标→取消→再次选卡”循环，确保 UI 不堆积节点且状态一致。"
          },
          {
            "id": "4",
            "title": "对齐 BattleManager.PlayCard 调用与失败提示",
            "description": "把交互闭环真正接到 BattleManager.PlayCard(heroId, cardId, targetId)，并实现失败原因提示。",
            "dependencies": [
              "3"
            ],
            "details": "成功路径：\n- 目标有效且能量足够 → 调用 PlayCard 并刷新 UI\n失败路径：\n- 能量不足/非法目标 → 不得 mutate battle state，并显示明确 reason\n提示形式：Toast/Label/弹层均可，但必须可被 headless test 断言到。",
            "status": "pending",
            "testStrategy": "GdUnit4：覆盖能量不足/非法目标失败时的“不变性”与提示可见性。"
          },
          {
            "id": "5",
            "title": "编写 headless 集成测试 test_battle_card_input_flow.gd",
            "description": "补齐 headless GdUnit4 集成测试，覆盖 play+cancel+invalid 三段流程并产出工件。",
            "dependencies": [
              "4"
            ],
            "details": "实现 Tests.Godot/tests/Integration/test_battle_card_input_flow.gd：\n- play: 选择卡+选择目标+出牌成功\n- cancel: 选择卡/目标后取消，回到 Idle\n- invalid: 能量不足/非法目标，状态不变且提示出现\nCI 工件：JUnit/XML + 可选截图，统一写入 logs/e2e/**。",
            "status": "pending",
            "testStrategy": "CI/headless 跑通 GdUnit4 Integration suite，并在 logs/e2e/** 下生成报告工件。"
          }
        ]
      },
      {
        "id": "56",
        "title": "实现敌人意图展示 UI (IntentView)",
        "description": "实现 PRD 要求的敌人意图（Intent）可视化：在敌方回合前展示下一次行动类型/数值/目标，并在回合推进时刷新。",
        "status": "pending",
        "priority": "medium",
        "dependencies": [
          "6",
          "20"
        ],
        "details": "Test Refs: Tests.Godot/tests/Integration/test_enemy_intent_ui_updates.gd\nAcceptance: BattleScreen displays enemy intents before the enemy acts and refreshes them at the defined phase boundaries.; Intent view is data-driven from Enemy.Intent and does not duplicate game logic in UI.; Add at least one headless GdUnit4 integration test (see test_refs) to validate intent refresh behavior.\nOverlays: docs/architecture/overlays/PRD-rouge-manager/08/_index.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Rouge-Run-Events.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Security.md; docs/architecture/overlays/PRD-rouge-manager/08/08-Contracts-Quality-Metrics.md; docs/architecture/overlays/PRD-rouge-manager/08/ACCEPTANCE_CHECKLIST.md\n",
        "testStrategy": "GdUnit4 集成测试验证 intent 可见性与刷新时机（回合推进/敌方行动后）。",
        "adrRefs": [
          "ADR-0011",
          "ADR-0018",
          "ADR-0021",
          "ADR-0024"
        ],
        "archRefs": [
          "CH01",
          "CH06",
          "CH07",
          "CH10"
        ],
        "overlay": "docs/architecture/overlays/PRD-rouge-manager/08/08-Feature-Slice-Minimum-Playable-Loop.md",
        "complexity": 5,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Break down this task with a focus on 实现敌人意图展示 UI (IntentView).",
        "updatedAt": null
      }
    ],
    "metadata": {
      "created": "2025-12-20T13:15:41.406Z",
      "updated": "2025-12-20T13:15:41.407Z",
      "description": "Tasks for master context",
      "version": "",
      "tags": [
        "master"
      ],
      "taskCount": 56,
      "completedCount": 0,
      "lastModified": "2025-12-20T13:15:41.407Z"
    }
  }
}
