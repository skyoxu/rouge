一，T2阶段「最小可玩闭环」PRD文档（类 Across the Obelisk 卡牌构筑RPG）

二，系统范围与目标
2.1 本项目是一款基于 Godot 4.x（Mono/.NET）、使用 C# 开发的 2D 单机卡牌构筑RPG（Roguelite）。核心玩法参考《Across the Obelisk》：玩家控制一支英雄小队，在分支地图上选择路线，遭遇战斗与事件，通过战后奖励与节点功能持续优化牌组与队伍状态，最终挑战 Boss 完成章节
2.2 范围：T2阶段聚焦“最小可玩闭环（MVP Run）”，实现从开局到 Boss 结算的一整套可重复循环流程。该阶段只实现各模块的“基本功能”，并在数据结构与接口上预留扩展能力。深度剧情长链、装备/遗物深系统、局外元进度（解锁、永久天赋）、复杂经济与锻造等内容不在 T2 必做范围内。
2.2.1 单机单人约束：本项目只做离线本地游玩体验，不设计远程通信能力或多用户协作玩法；若未来需求变化，需另立 PRD/ADR 再评估。
2.3 目标：实现完整玩法闭环：开始新局 → 选择队伍/初始牌组 → 进入章节地图 → 选择节点路线 →（战斗/事件/休息/商店）→ 战后奖励与构筑调整 → 推进至 Boss → 胜利结算（或失败结算）→ 可立即重开下一局。该阶段必须验证：卡牌出牌与效果结算正确、战斗回合流畅、地图推进稳定、奖励/构筑可形成“变强”的手感。
2.4 BMAD（用于对齐设计意图）：B（Behavior 行为）：选路—战斗出牌—结算奖励—改牌组—再选路；M（Motivation 动机）：用有限资源做更强构筑，赢下 Boss；A（Aesthetics 审美）：清晰可读的数值与状态反馈、明确的敌人意图展示、出牌响应“爽快”；D（Dynamics 动态）：风险/收益权衡（路线与精英）、构筑协同（状态与连携）、资源管理（生命/金币/牌组密度）

三，用户故事：
3.1 路径选择：作为玩家，我希望在章节地图上选择下一步要走的节点路线，以在风险与收益之间做决策（战斗/事件/商店/休息/精英/Boss）。
3.2 回合出牌：作为玩家，我希望在战斗中抽牌、消耗能量打出卡牌，对敌人造成伤害或施加状态、为队友提供护盾与增益，从而通过策略赢得战斗。
3.3 敌人意图：作为玩家，我希望在敌方回合前看到敌人的行动意图（攻击/防御/上状态），以做出针对性的防御或控场决策。
3.4 构筑成长：作为玩家，我希望战斗胜利后获得卡牌/金币/升级等回报，并能做选择，把牌组逐步打磨成更稳定的构筑。
3.5 事件抉择：作为玩家，我希望在事件节点看到清晰选项，并体验“拿奖励/承受代价/触发额外战斗”等变化，让每局流程不完全重复。
3.6 失败重开：作为玩家，当小队全灭时我希望快速进入结算并可立刻重开下一局，形成短周期、强复玩体验。

四，功能模块
T2阶段的功能划分如下，每个模块对应闭环中的关键功能点（每个模块都要“可用且可扩展”，但不追求内容量爆炸）。

4.1 地图与节点管理
4.1.1 章节地图：一张“分层节点图”（建议 8–12 个普通节点 + 1 个 Boss），每一层提供 1–3 个可选节点，节点之间用连线表示可达路径。玩家从起点出发，完成当前节点内容后才能进入下一层。
4.1.2 节点类型（T2最小集）：
    a.战斗节点：普通敌群遭遇；
    b.事件节点：文本 + 选项 + 结果；
    c.休息节点：回血/升级卡（二选一）；
    d.商店节点：购买卡牌/移除卡（可先做简化版本）；
    e.精英节点（可选）：更强敌群 + 更好奖励；
    f.Boss节点：章节终点
4.1.3 推进规则：只允许从当前节点移动到下一层中“与当前节点连线相连”的节点。节点完成后标记 completed，回到地图解锁下一次选择。Boss 胜利触发“章节完成结算”。
4.1.4 扩展预留：多章节（Act 1/2/3）、隐藏路线、事件解锁新连线、地图随机生成（模板/权重）、精英与Boss词缀系统。

4.2 小队与英雄
4.2.1 队伍规模：T2建议先落地 2 名英雄（架构支持扩展到 4 名英雄）。单机模式下玩家控制全队。
4.2.2 英雄数据：每名英雄至少包含：
    a.基础属性：最大生命、当前生命、基础能量上限（每回合重置）、基础攻击/防御/速度（T2可弱化为不做速度）
    b.职业/定位：决定初始牌组与可选卡池（例如战士/法师/牧师/游侠）
    c.战斗临时状态：护盾、增益/减益状态列表（战斗结束清除；生命变化保留）
4.2.3 英雄牌组：T2建议“每个英雄独立牌组与手牌”（更贴近 Across），但实现层面可在 UI 上统一呈现并按英雄切换出牌（或同屏两套手牌，视 UI 复杂度决定）。
4.2.4 扩展预留：装备栏、天赋树、职业被动、召唤物。

4.3 卡牌与牌组
4.3.1 卡牌定义：每张卡牌包含至少：
    a.ID、名称、描述文本
    b.能量消耗（或特殊消耗规则）
    c.类型：攻击/防御/技能
    d.目标规则：单体敌方/全体敌方/己方单体/全队/随机
    f.效果列表：数据驱动的“效果指令序列”（见“统一效果系统”）
4.3.2 牌堆结构：每名英雄拥有：
抽牌堆（DrawPile）、手牌（Hand）、弃牌堆（DiscardPile）、消耗堆（Exhaust，可选）
基本操作：洗牌、抽牌、弃牌、手牌上限、抽牌堆空时将弃牌堆洗回抽牌堆。
4.3.3 卡牌升级（T2可做简化但要预留）：升级一张牌等价于把牌 ID 替换为升级版 ID（例如 Card_001 → Card_001_plus），升级版定义在配置中。
4.3.4 扩展预留：关键字系统（Tag/Keyword）、稀有度与奖励权重、牌库移除、遗物对卡牌效果的修正。

4.4 战斗系统（回合制）
4.4.1 战斗参与者：英雄若干 + 敌人若干（敌群来自 Encounter 配置）。
4.4.2 回合结构（T2建议）：玩家回合 → 敌方回合（先不做速度条），每回合包含明确阶段（见“回合机制详述”）。
4.4.3 能量与抽牌：玩家回合开始刷新每名英雄能量并抽牌。能量不足则不能打出卡牌（除非卡牌特殊规则）。
4.4.4 伤害与护盾：优先扣护盾再扣生命。护盾在回合结束是否清零需在 PRD 固化一条规则（建议：护盾回合结束清零，便于实现与平衡；后续可用状态实现“保留护盾”）。
4.4.5 状态系统（T2最小状态集合）：
    a.力量（Strength）：造成伤害 +X
    b.虚弱（Weak）：造成伤害 -Y 或乘区间系数（T2建议用 -Y 简化）
    c.易伤（Vulnerable）：受到伤害 +Z（可用 +% 或 +固定，T2建议 +%）
    d.中毒（Poison）：回合开始或回合结束结算伤害并衰减
    f.护盾/格挡（Block）：抵挡伤害
4.4.6 敌人意图（Intent）：敌人每回合生成“下一次行动预告”，玩家回合可见。敌方回合按意图执行。
4.4.7 胜负判定：敌方全灭则胜利进入奖励；英雄全灭则失败进入本局结算（Run End）。
4.4.8 扩展预留：更复杂行动顺序、敌人技能循环更丰富、环境效果。

4.5 奖励与构筑调整
4.5.1 战斗奖励（T2最小集）：
    a.卡牌奖励：战斗胜利后，从 3 张候选卡中选 1 张加入某英雄牌组（或按规则指定英雄）
    b.金币奖励：用于商店
    c.（可选）小额治疗：用于缓和曲线（也可全部交给休息点）
4.5.2 休息节点（T2最小集）：二选一：
    a.回复生命：固定值或百分比
    b.升级一张卡：从该英雄牌组中选择一张升级
4.5.3 商店节点（T2可简化但要形成闭环）：
    a.购买卡牌：提供少量卡牌售卖（可按职业池）
    b.移除卡牌：支付金币移除一张牌（强力构筑工具）
4.5.4 扩展预留：遗物/饰品掉落、精英专属奖励、卡牌升级服务、稀有度与折扣系统。

4.6 事件系统
4.6.1.事件节点：展示事件文本与 2–3 个选项。玩家选择一个选项后，系统应用 effects 并返回地图。
4.6.2.事件效果：必须复用“统一效果系统”的指令集（例如 GainGold、Heal、Damage、AddCardToDeck、TriggerBattle 等），避免事件系统自成一套逻辑。
4.6.3.条件选项（T2可最小实现）：例如金币不足选项置灰，或提示不可选。概率分支与检定可先留字段不实现或实现极简。
4.6.4.事件标记（可选）：eventFlags 记录关键抉择，供后续事件或地图解锁条件使用（T2可先少量使用或仅保留结构）。
4.6.5.扩展预留：事件链、章节剧情、职业专属选项、概率检定与属性判定。

4.7 系统服务与跨切面能力（T2必须落地的“工程底座”）
4.7.1 事件总线（EventBus）：核心逻辑与 UI 层解耦通信（核心发事件，UI 订阅刷新）。
4.7.2 随机数服务（RngService）：统一管理随机源，并支持 Seed 固定以保证可复现（用于调试、自动化测试、复盘）。
4.7.3 数据存储（DataStore）：存档保存/读取（T2可做最小实现：保存 RunSeed、地图进度、英雄HP与牌组、金币、flags）。
4.7.4 日志（Logger）：关键流程打点（战斗开始/出牌/结算/奖励选择/失败原因），便于定位问题。
4.7.5 本地化（可选但建议预留）：文本使用 key 映射（卡牌描述、事件文本），后续多语言不改逻辑。

4.8 回合机制详述
4.8.1 战斗回合（每场战斗）具体流程如下（T2必须按此状态机实现，避免后续功能分歧）：
4.8.2 战斗开始：
    a.初始化战斗实例（英雄队伍与敌群）
    b.清空战斗临时状态（护盾、临时buff等）
    c.为每个敌人生成 Intent（下一回合动作预告）
    d.触发 BattleStarted 事件（UI 切场、展示敌人）
4.8.3 玩家回合开始（TurnStart）：
    a.每名英雄能量重置为上限（可配置）
    b.为每名英雄抽牌（可配置，建议每回合 5 张；或初始抽牌 5，之后每回合抽 5）
    c.结算 OnTurnStart 状态（例如中毒、衰减等——结算点必须固定）
    d.触发 PlayerTurnStarted 事件（UI 更新能量/手牌/状态）
4.8.4 玩家行动阶段（Main）：
    a.玩家选择一个英雄与一张手牌，选择目标（按卡牌目标规则）
    b.校验：能量是否足够、目标是否合法、卡牌是否可用
    c.执行：将卡牌效果指令送入 EffectResolver 逐条结算
    d.更新：扣能量、移动卡牌到弃牌堆/消耗堆、刷新UI
    e.在任意单位 HP 变化后立即触发死亡处理与胜负检查（见“胜负判定触发点”）
4.8.5 玩家回合结束（TurnEnd）：
    a.弃掉剩余手牌（或按规则保留——T2建议全部弃牌简化）
    b.结算 OnTurnEnd 状态（护盾清零、持续回合数衰减等——结算点必须固定）
    c.（可选）在此时刷新敌人下一回合 Intent（或在敌方回合结束刷新，但必须统一）
    d.触发 PlayerTurnEnded 事件
4.8.6 敌方回合：
    a.按敌人顺序执行其 Intent（Intent 本质也是“效果指令序列”）
    b.每个敌人执行前/后可触发 AIActStarted/AIActEnded 事件（用于动画节奏）
    c.执行过程中同样走 EffectResolver，保证伤害/状态规则一致
    d.敌方回合结束后刷新下一回合 Intent
    e.触发 EnemyTurnEnded 事件
4.8.7 胜负判定触发点（必须明确）：
    a.任意效果导致单位 HP <= 0 时立即进入死亡处理（移出行动列表、触发 UnitDied 事件）
    b.每次死亡处理后立即检查：
    c.敌方是否全灭 → BattleWon → 进入奖励流程
    d.我方是否全灭 → BattleLost → 进入本局结算流程

4.9 时间推进规则详述（这里的“时间”指一局冒险的节点推进节拍）
4.9.1 一局（Run）的推进以“节点完成”为最小单位，“地图选择 → 节点内容 → 节点结算 → 回到地图”循环，直到 Boss 胜利或全灭失败。
4.9.2 开始新局：
    a.生成 RunSeed（记录在 GameState）
    b.初始化队伍与初始牌组
    c.生成本章地图（固定模板或随机）
    d.进入地图界面，定位在起点节点
4.9.3 地图选择：
    a.高亮当前可达节点（下一层连线节点）
    b.玩家选择一个节点 → 进入对应节点内容
4.9.4 节点内容与结算：
    a.战斗节点：进入战斗 → 胜利进入奖励选择（卡牌/金币等）→ 回到地图并标记节点完成；失败进入本局结算
    b.事件节点：展示事件 → 选择选项 → 执行 effects → 回到地图并标记节点完成
    c.休息节点：二选一（回血/升级卡）→ 回到地图并标记节点完成
    d.商店节点：购买/移除（可多次直到离开）→ 回到地图并标记节点完成
    e.Boss节点：进入 Boss 战 → 胜利进入章节结算/通关结算；失败进入本局结算
4.9.5 章节完成：
    a.若仅做单章节：Boss 胜利即通关结算，显示统计（用时、获得卡牌数、金币等），可重开
    b.若预留多章节：进入下一章节地图生成与过渡（可在 T2 仅保留接口，不必实现内容）


五，系统架构设计

5.1 系统上下文
5.1.1 本游戏为离线单机系统，运行于本地 Godot 客户端进程内。外部交互边界主要为：
    a.输入：键鼠/手柄 → UI 操作（选路、出牌、目标选择）
    b.输出：渲染/音频/动画 → 玩家反馈
    c.存储：本地文件系统 user://（存档、日志、可选配置覆盖）

5.2 模块分层（C4容器视图）
5.2.1 为满足可测试与可扩展要求，建议采用“核心逻辑与引擎解耦”的分层结构（端口-适配器思想）：
5.2.2 游戏核心逻辑 (Game.Core)：
纯 C# 的领域层，包含规则与数据模型：卡牌、牌堆、战斗状态机、效果解析、地图推进、事件解析、奖励生成、GameState。Core 不直接依赖 Godot API，便于 xUnit 单测与工具链（模拟器/回放/批量对局验证）。
5.2.3 Godot 表现层 (Game.Godot)：
Godot 场景树、UI、输入、动画与音效。该层通过调用 Core 的用例接口驱动逻辑，并订阅 Core 发出的领域事件刷新表现。UI 不直接改 Core 状态，避免逻辑分叉。
5.2.4 事件与系统服务（Autoload）：
全局服务模块：EventBus、RngService、DataStore、Logger、ConfigService、AudioService 等。服务模块在 Godot 启动时加载，为 Core 与 UI 提供基础设施能力。
5.2.5 存储容器：
本地文件系统（JSON 或二进制）。Core 定义 GameState 结构并提供序列化 DTO，Godot 层通过 IDataStore 写入/读取。T2可以做到“保存/加载一次”，不要求多存档位，但必须预留 Version 以便迁移。

5.3 主要组件与类设计（C4组件视图）
5.3.1 Game.Core（领域模型 / 用例）
AdventureMap：地图数据结构，节点列表、连线、当前节点、已完成节点集合
MapNode：节点类型、层级、可达关系、节点参数（敌群ID/事件ID/商店表ID等）
Party：队伍容器，维护英雄列表与共享资源（金币、flags等）
Hero：英雄属性（HP/能量上限/职业ID/牌组引用）、战斗临时状态入口
Deck/Hand/Discard/Exhaust：牌堆容器与操作（抽、弃、洗、移除、升级替换）
CardDefinition：卡牌静态数据（消耗、目标规则、效果指令列表、文本key）
CardInstance：卡牌实例（可含临时强化、费用变化、回合内标记）
BattleManager：战斗状态机（阶段推进、胜负判定、行动入口）
Enemy/EnemyAI：敌人数据与意图生成（最小 IntentTable 实现）
EffectResolver：统一效果解析与执行（卡牌/事件/意图/奖励复用）
StatusManager：状态管理（叠加、衰减、结算时机）
RewardManager：奖励生成（候选卡、金币、掉落权重）
EventManager：事件抽取、选项处理、effects 执行
GameState：存档快照（RunSeed、地图进度、队伍状态、牌组、金币、flags、版本号）

5.3.2 Game.Godot（场景与UI）
MainScene：主菜单、新局/继续、设置
MapScreen：地图渲染、节点选择、进入节点内容
BattleScreen：战斗界面（手牌、能量、状态、敌人意图、目标选择、回合按钮）
CardView/HandView：卡牌UI组件（点击/拖拽出牌）
EventDialog：事件展示与选项按钮
RewardPanel：战后奖励选择（选卡加入牌组）
RestPanel：回血/升级卡选择
ShopPanel：购买/移除操作（T2可简化）
RunEndScreen：胜利/失败结算与重开

5.4 节点脚本与信号（必须作为工程约束写死，避免实现分叉）
5.4.1 交互范式：
Godot UI 脚本只负责收集输入与触发用例：例如点击“出牌”→ 调用 BattleManager.PlayCard(cardId, heroId, targetId)
Core 不直接操作 Godot Node：Core 通过 EventBus 发布领域事件（CardPlayed、UnitDamaged、StatusApplied、BattleWon 等）
Godot 层订阅事件后刷新 UI 与播放动画：例如收到 UnitDamaged → 播放受击动画 → 更新血条

5.4.2 动画与逻辑顺序：
逻辑先行：Core 先完成数值与状态结算并发事件
表现可延迟：UI 可以在播放动画期间锁输入，但不得改变逻辑结果
需要“节奏”时用事件队列或命令队列：BattleScreen 逐个消费事件并播放对应效果（但不回写逻辑）

5.5 统一效果系统（T2最关键约束，必须完整覆盖）
5.5.1 目的：卡牌效果、敌人意图、事件选项、奖励结算全部使用同一套“效果指令 → EffectResolver → 状态/数值变更”。
5.5.2 指令基本形态（示例，T2至少实现这些类型）：
Damage(target, amount, type)
GainBlock(target, amount)
Heal(target, amount)
ApplyStatus(target, statusId, stacks, duration)
Draw(hero, n)
ChangeEnergy(hero, delta)
GainGold(amount) / LoseGold(amount)
AddCardToDeck(hero, cardId)
RemoveCardFromDeck(hero, cardId)
UpgradeCardInDeck(hero, cardId)
TriggerBattle(encounterId)（事件用，可选）
SetFlag(flagId, value)（事件链预留）
5.5.3 状态结算时机（必须固定）：
OnTurnStart：例如中毒结算、回合开始衰减
OnTurnEnd：例如护盾清零、持续回合数衰减
OnHit：例如易伤增伤、反伤（T2可先只做易伤/虚弱相关）
5.5.4 叠加规则（T2必须选定一条并贯彻）：
stacks 叠加：同状态重复施加时 stacks 相加
duration 处理：可选“刷新为最大值”或“相加”（建议 T2 采用刷新为最大值，避免爆炸）
某些状态可只用 stacks 表示持续回合数（简化实现），但必须写入 StatusDefinition 以便统一解释

5.6 非功能需求与质量目标（T2必须）
5.6.1 确定性：同一 RunSeed + 同一输入序列，抽牌、事件抽取、奖励候选应可复现（至少在 Core 层可复现），用于回放、调试与自动化测试。
5.6.2 可测试性：Core 无 Godot 依赖，核心规则（抽弃洗、效果结算、状态机推进）有 xUnit 覆盖。
5.6.3 可扩展性：内容（卡/敌/事件/遭遇/奖励）尽量数据驱动；新增内容不改状态机，只扩配置与效果指令实现。
5.6.4 性能底线：战斗 UI 在普通规模（2–4 英雄，1–4 敌人）保持流畅；逻辑结算集中在回合/出牌触发点，不在每帧做大量循环。

5.7 数据与配置规范（用于保证“不遗漏”和可持续扩展）
5.7.1 静态配置（Content，建议以 JSON 或 Godot Resource 管理）：
Cards：卡牌定义（含效果指令列表、文本key、稀有度、职业标签）
Statuses：状态定义（叠加规则、结算时机、UI 图标key）
Enemies：敌人定义（属性、技能/意图表、掉落权重）
Encounters：敌群组合（用于战斗节点）
Events：事件定义（文本key、选项、effects、条件）
Rewards：奖励权重与过滤规则（按章节/节点类型）
5.7.2 运行态存档（State，GameState 最小字段集合）：
Version
RunSeed
CurrentAct/Chapter（T2可固定为 1）
Map：节点完成情况、当前节点、地图生成参数
Party：金币、flags
Heroes：每名英雄的 HP/MaxHP、牌组（卡牌ID列表）、升级信息（若实现）
可选：统计信息（击杀数、获得卡牌数等）

六，总结与下一步

6.1 T2验收标准（DoD，必须全部满足才算“闭环已跑通”）
6.1.1 流程闭环：
    a.从主菜单开始可“开始新局”，生成地图并进入地图界面
    b.地图至少包含：战斗节点、事件节点、休息节点、商店节点、Boss 节点（节点数量≥8+Boss）
    c.任意节点完成后可回到地图并继续选择下一节点
    d.Boss 战胜利进入通关结算界面，可重开下一局
    e.小队全灭进入失败结算界面，可重开下一局
6.1.2 战斗闭环：
    a.玩家回合：抽牌、能量、出牌、目标选择、效果结算正常
    b.敌方回合：Intent 可见且按意图执行
    c.至少 5 种卡牌效果可用（伤害/护盾/治疗/上状态/抽牌）
    d.至少 4 种状态可用（力量/虚弱/易伤/中毒或护盾相关）
    e.胜负判定稳定，不出现卡死或状态机错乱
6.1.3 构筑闭环：
    a.战斗胜利必定进入奖励选择，并能把卡牌加入牌组
    b.休息节点可回血或升级一张卡（升级版可用独立ID实现）
    c.商店至少支持“移除一张卡”或“购买一张卡”之一（建议两者都做以形成闭环）
6.1.4 工程底座：
    a.RunSeed 可记录并用于复现（至少 Core 层抽牌与奖励候选可复现）
    b.xUnit 覆盖：牌堆洗抽弃、EffectResolver（Damage/Status）、BattleManager 状态机推进
    c.GdUnit4（或最小手动冒烟测试脚本）覆盖：出牌按钮/结束回合/节点点击流程无断链
    d.存档（可选但建议）：非战斗状态可保存并加载继续（至少保存一次）

6.2 与现有仓库结构兼容声明
6.2.1 如果你的 godotgame 仓库目前为空或只有 Godot 模板工程：按上述 Game.Core / Game.Godot 分层创建最小目录与工程引用关系即可。
6.2.2 如果仓库已存在既定目录（例如已有 Autoload、已有 EventBus 或 DataStore）：优先复用现有命名与入口，确保只补“缺失模块”，不引入第三套并行架构。Core 与 Godot 的边界仍以“Core 不依赖 Godot API、UI 通过事件订阅刷新”为硬约束。

6.3 下一步实施顺序建议（用于后续 task master 拆解时保持依赖清晰）
6.3.1 第一优先级（闭环骨架）：
    a.GameState + RngService（Seed） + EventBus
    b.牌堆与卡牌定义（抽/弃/洗）+ EffectResolver（最小指令集）
    c.BattleManager 状态机（玩家回合/敌方回合/胜负）
    d.BattleScreen UI（能量、手牌、目标选择、意图显示）
6.3.2 第二优先级（跑通一局）：
    a.地图生成与 MapScreen（节点点击→进入战斗/事件）
    b.RewardManager + RewardPanel（选卡加入牌组）
    c.EventManager + EventDialog（事件选项 effects 复用指令集）
    d.RestPanel（回血/升级卡）
    e.ShopPanel（移除/购买）
6.3.3 第三优先级（质量与扩展）：
    a.更多卡牌/敌人/事件内容量
    b.日志与复现工具（输入记录、关键事件序列）
    c.更完整的存档与版本迁移
    d.为后续装备/剧情扩展预留接口与数据字段
