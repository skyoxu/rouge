#!/usr/bin/env python3
"""
Apply acceptance-alignment outputs (generated by scripts/sc/llm_align_acceptance_semantics.py)
into task view files, without re-running LLM calls.

Why:
  llm_align_acceptance_semantics.py writes tasks_back.json/tasks_gameplay.json only at the end.
  When a long run times out, we still have per-task output.json under logs/ci/.../task-<id>/.
  This script replays those outputs and writes the view task files deterministically (UTF-8).

Inputs:
  logs/ci/<YYYY-MM-DD>/sc-llm-align-acceptance-semantics/task-<id>/output.json

Outputs:
  - Updates:
      .taskmaster/tasks/tasks_back.json
      .taskmaster/tasks/tasks_gameplay.json
  - Audit:
      logs/ci/<YYYY-MM-DD>/sc-llm-align-acceptance-semantics/replay-summary.json
"""

from __future__ import annotations

import argparse
import json
import re
import sys
from dataclasses import asdict
from pathlib import Path
from typing import Any


def repo_root() -> Path:
    return Path(__file__).resolve().parents[2]


def today_str() -> str:
    # Keep it local-date aligned with other scripts in this repo.
    import datetime as dt

    return dt.date.today().strftime("%Y-%m-%d")


def _read_json(path: Path) -> Any:
    return json.loads(path.read_text(encoding="utf-8"))


def _write_json(path: Path, payload: Any) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(payload, ensure_ascii=False, indent=2) + "\n", encoding="utf-8", newline="\n")


def _task_id_from_dir(name: str) -> int | None:
    m = re.match(r"^task-(\d+)$", name.strip())
    if not m:
        return None
    try:
        return int(m.group(1))
    except ValueError:
        return None


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--date", default=today_str(), help="logs/ci/<date>/ date (YYYY-MM-DD).")
    ap.add_argument("--task-ids", default="", help="Optional CSV task ids filter (e.g. 1,2,7).")
    ap.add_argument("--apply", action="store_true", help="Write changes into view files.")
    args = ap.parse_args()

    root = repo_root()
    sc_dir = root / "scripts" / "sc"
    sys.path.insert(0, str(sc_dir))

    # Reuse the exact writer/utilities used by sc scripts to avoid format drift.
    from _taskmaster import default_paths, load_json  # type: ignore
    from _util import write_json  # type: ignore
    from _acceptance_semantics_align import apply_acceptance, apply_description, find_view_entry  # type: ignore

    tasks_json_path, tasks_back_path, tasks_gameplay_path = default_paths()
    back = load_json(tasks_back_path)
    gameplay = load_json(tasks_gameplay_path)
    if not isinstance(back, list) or not isinstance(gameplay, list):
        print("REPLAY_ALIGN status=fail reason=views_not_arrays")
        return 2

    out_dir = root / "logs" / "ci" / str(args.date) / "sc-llm-align-acceptance-semantics"
    if not out_dir.exists():
        print(f"REPLAY_ALIGN status=fail reason=missing_out_dir dir={out_dir}")
        return 2

    filter_ids: set[int] | None = None
    if str(args.task_ids).strip():
        ids: set[int] = set()
        for tok in str(args.task_ids).split(","):
            t = tok.strip()
            if t.isdigit():
                ids.add(int(t))
        filter_ids = ids

    applied: list[dict[str, Any]] = []
    skipped: list[dict[str, Any]] = []
    failed: list[dict[str, Any]] = []

    for d in sorted([p for p in out_dir.iterdir() if p.is_dir()], key=lambda p: p.name):
        task_id = _task_id_from_dir(d.name)
        if task_id is None:
            continue
        if filter_ids is not None and task_id not in filter_ids:
            continue

        out_path = d / "output.json"
        if not out_path.exists():
            skipped.append({"task_id": task_id, "reason": "missing_output_json"})
            continue

        try:
            out_obj = _read_json(out_path)
        except Exception as ex:
            failed.append({"task_id": task_id, "reason": f"read_output_json:{ex!r}"})
            continue

        if not isinstance(out_obj, dict):
            failed.append({"task_id": task_id, "reason": "output_not_object"})
            continue

        back_entry = find_view_entry(back, task_id=task_id)
        gameplay_entry = find_view_entry(gameplay, task_id=task_id)
        if back_entry is None and gameplay_entry is None:
            skipped.append({"task_id": task_id, "reason": "missing_both_views"})
            continue

        try:
            if back_entry is not None and isinstance(out_obj.get("back"), dict):
                b = out_obj["back"]
                if "description" in b:
                    apply_description(back_entry, b.get("description"))
                if isinstance(b.get("acceptance"), list):
                    apply_acceptance(back_entry, b.get("acceptance") or [])

            if gameplay_entry is not None and isinstance(out_obj.get("gameplay"), dict):
                g = out_obj["gameplay"]
                if "description" in g:
                    apply_description(gameplay_entry, g.get("description"))
                if isinstance(g.get("acceptance"), list):
                    apply_acceptance(gameplay_entry, g.get("acceptance") or [])
        except Exception as ex:
            failed.append({"task_id": task_id, "reason": f"apply_failed:{ex!r}"})
            continue

        applied.append(
            {
                "task_id": task_id,
                "dir": str(d.relative_to(root)).replace("\\", "/"),
                "applied_back": bool(back_entry is not None and isinstance(out_obj.get("back"), dict)),
                "applied_gameplay": bool(gameplay_entry is not None and isinstance(out_obj.get("gameplay"), dict)),
            }
        )

    summary = {
        "date": str(args.date),
        "apply": bool(args.apply),
        "out_dir": str(out_dir.relative_to(root)).replace("\\", "/"),
        "applied": applied,
        "skipped": skipped,
        "failed": failed,
        "counts": {"applied": len(applied), "skipped": len(skipped), "failed": len(failed)},
    }
    _write_json(out_dir / "replay-summary.json", summary)

    if not args.apply:
        print(f"REPLAY_ALIGN status=dry_run applied={len(applied)} skipped={len(skipped)} failed={len(failed)} out={out_dir}")
        return 0 if len(failed) == 0 else 1

    # Persist view files using the same serializer as sc scripts, but only if we actually applied anything.
    if len(applied) > 0:
        write_json(tasks_back_path, back)
        write_json(tasks_gameplay_path, gameplay)

    status = "ok" if len(failed) == 0 else "warn"
    print(f"REPLAY_ALIGN status={status} applied={len(applied)} skipped={len(skipped)} failed={len(failed)} out={out_dir}")
    return 0 if status == "ok" else 1


if __name__ == "__main__":
    raise SystemExit(main())
